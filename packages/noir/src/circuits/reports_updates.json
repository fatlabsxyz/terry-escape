{"noir_version":"1.0.0-beta.2+1a2a08cbcb68646ff1aaef383cfc1798933c1355","hash":9967971839095258342,"abi":{"parameters":[{"name":"board_used","type":{"kind":"array","length":16,"type":{"kind":"field"}},"visibility":"private"},{"name":"old_board_salt","type":{"kind":"field"},"visibility":"private"},{"name":"new_board_salt","type":{"kind":"field"},"visibility":"private"},{"name":"reason","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"target","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"trap","type":{"kind":"boolean"},"visibility":"private"},{"name":"action_salt","type":{"kind":"field"},"visibility":"private"},{"name":"params","type":{"kind":"struct","path":"bignum::params::BigNumParams","fields":[{"name":"has_multiplicative_inverse","type":{"kind":"boolean"}},{"name":"modulus","type":{"kind":"array","length":9,"type":{"kind":"field"}}},{"name":"modulus_u60","type":{"kind":"struct","path":"bignum::utils::u60_representation::U60Repr","fields":[{"name":"limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":64}}}]}},{"name":"modulus_u60_x4","type":{"kind":"struct","path":"bignum::utils::u60_representation::U60Repr","fields":[{"name":"limbs","type":{"kind":"array","length":36,"type":{"kind":"integer","sign":"unsigned","width":64}}}]}},{"name":"double_modulus","type":{"kind":"array","length":9,"type":{"kind":"field"}}},{"name":"redc_param","type":{"kind":"array","length":9,"type":{"kind":"field"}}}]},"visibility":"private"},{"name":"decryption_key","type":{"kind":"array","length":9,"type":{"kind":"field"}},"visibility":"private"},{"name":"hit_reports","type":{"kind":"array","length":3,"type":{"kind":"array","length":9,"type":{"kind":"field"}}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"field"},{"kind":"field"},{"kind":"field"},{"kind":"field"}]},"visibility":"public"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13265554733035650515":{"error_kind":"string","string":"BigNum::validate_gt check fails"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"3":{"source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        /// Safety: `sorted` array is checked to be:\n        /// a. a permutation of `input`'s elements\n        /// b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n}\n","path":"std/array/mod.nr"},"6":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"13":{"source":"// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n","path":"std/convert.nr"},"18":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    /// Safety: borrow is enforced to be boolean due to its type.\n    /// if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    /// if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        /// Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            /// Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        /// Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"19":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"21":{"source":"pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    /// Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"30":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod bigint;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    /// Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    /// Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n}\n","path":"std/lib.nr"},"62":{"source":"use bignum::params::BigNumParams;\nuse bignum::RuntimeBigNum::from_array;\nuse cheon_stehle::decrypt;\nuse std::hash::pedersen_hash as hash;\n\nglobal Players: u32 = 4;\nglobal Size: u32 = 16;\nglobal Limbs: u32 = 9;\nglobal Bits: u32 = 1031;\n\nfn tile_has_trap(tile: Field) -> bool {\n    tile == 0\n}\nfn tile_has_agent(tile: Field) -> bool {\n    (tile != 0) & (tile != 1)\n}\n\n\n#[oracle(oracle_board)]\nunconstrained fn oracle_board(board: [Field; Size]) -> () {}\nunconstrained fn output_board(board: [Field; Size]) -> () {\n    oracle_board(board);\n}\n#[oracle(oracle_detect)]\nunconstrained fn oracle_detect(detect: u32) -> () {}\nunconstrained fn output_detect(detect: u32) -> () {\n    oracle_detect(detect);\n}\n\nfn main(\n    mut board_used: [Field; Size],\n    old_board_salt: Field,\n    new_board_salt: Field,\n    reason: u32,\n    target: u32,\n    trap: bool,\n    action_salt: Field,\n    params: BigNumParams<Limbs, Bits>,\n    decryption_key: [Field; Limbs],\n    hit_reports: [[Field; Limbs]; Players - 1],\n) -> pub (Field, Field, Field, Field) {\n    let old_board_digest = hash([old_board_salt, hash(board_used)]);\n    let action_digest = hash(\n        [action_salt, reason as Field, target as Field, trap as Field],\n    );\n\n    let decryption_key_digest = hash(decryption_key);\n    let dk = from_array(params, decryption_key);\n    let detect = hit_reports.any(|encrypted_report| {\n        decrypt(dk, from_array(params, encrypted_report))\n    })\n        | (trap & tile_has_agent(board_used[target]))\n        | tile_has_trap(board_used[target]);\n\n    if trap {\n        board_used[target] = 0; // Trap\n    } else {\n        board_used[reason] -= 1; // Decrement agents\n        board_used[target] += 1; // Increment agents\n    }\n    if detect {\n        board_used[target] = 1; // Void tile\n        let _ = unsafe { output_detect(target) };\n    }\n\n    let _ = unsafe { output_board(board_used) };\n    let new_board_digest = hash([new_board_salt, hash(board_used)]);\n\n    (old_board_digest, new_board_digest, action_digest, decryption_key_digest)\n}\n","path":"/root/aztec-grant-pss/circuits/reports_updates/src/main.nr"},"96":{"source":"use crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__add, __div, __mul, __neg, __sub, __udiv_mod},\n};\nuse crate::params::BigNumParams as P;\n\nglobal TWO_POW_120: Field = 0x1000000000000000000000000000000;\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n */\n\npub(crate) fn limbs_to_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    limbs: [Field; N],\n) -> Field {\n    let TWO_POW_120 = 0x1000000000000000000000000000000;\n    if N > 2 {\n        // validate that the limbs is less than the modulus the grumpkin modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, MOD_BITS>(grumpkin_modulus, limbs);\n        // validate that the limbs are in range\n        validate_in_range::<N, MOD_BITS>(limbs);\n    }\n    // validate the limbs sum up to the field value\n    if N < 2 {\n        limbs[0]\n    } else if N == 2 {\n        validate_in_range::<N, MOD_BITS>(limbs);\n        limbs[0] + limbs[1] * TWO_POW_120\n    } else {\n        // validate_in_range::<N, 254>(limbs);\n        limbs[0] + limbs[1] * TWO_POW_120 + limbs[2] * TWO_POW_120 * TWO_POW_120\n    }\n}\n\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    field: Field,\n) -> [Field; N] {\n    // Safety: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result = unsafe { __from_field::<N>(field) };\n\n    if !std::runtime::is_unconstrained() {\n        // validate the limbs are in range and the value in total is less than 2^254\n\n        let TWO_POW_120 = 0x1000000000000000000000000000000;\n        // validate that the last limb is less than the modulus\n        if N > 2 {\n            // validate that the result is less than the modulus\n            let mut grumpkin_modulus = [0; N];\n            grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n            grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n            grumpkin_modulus[2] = 0x3064;\n            validate_gt::<N, MOD_BITS>(grumpkin_modulus, result);\n            // validate that the limbs are in range\n            validate_in_range::<N, MOD_BITS>(result);\n        }\n        // validate the limbs sum up to the field value\n        let field_val = if N < 2 {\n            result[0]\n        } else if N == 2 {\n            validate_in_range::<N, MOD_BITS>(result);\n            result[0] + result[1] * TWO_POW_120\n        } else {\n            validate_in_range::<N, MOD_BITS>(result);\n            result[0] + result[1] * TWO_POW_120 + result[2] * TWO_POW_120 * TWO_POW_120\n        };\n        assert(field_val == field);\n    }\n\n    result\n}\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        std::hash::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[Field; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [Field; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n        let mut num_remaining_limbs =\n            (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n        let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n        let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n            + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n        for j in 0..num_limbs_in_bigfield {\n            let mut limb: Field = 0;\n            for _ in 0..15 {\n                let need_more_bytes = (byte_ptr < num_bytes);\n                let mut byte = hash_buffer[byte_ptr];\n                limb *= (256 * need_more_bytes as Field + (1 - need_more_bytes as Field));\n                limb += byte as Field * need_more_bytes as Field;\n                byte_ptr += need_more_bytes as u32;\n            }\n            bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n        }\n        bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n    }\n\n    let mut bigfield_rhs_limbs: [Field; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [Field; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n    result\n}\n\n/**\n* @brief conditional_select given the value of `predicate` return either `self` (if 0) or `other` (if 1)\n* @description should be cheaper than using an IF statement (TODO: check!)\n**/\npub(crate) fn conditional_select<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n    predicate: bool,\n) -> [Field; N] {\n    let mut result: [Field; N] = lhs;\n    for i in 0..N {\n        result[i] = (lhs[i] - rhs[i]) * predicate as Field + rhs[i];\n    }\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    for i in 0..N {\n        l *= TWO_POW_120;\n        r *= TWO_POW_120;\n        modulus_mod_n *= TWO_POW_120;\n        l += lhs[N - i - 1];\n        r += rhs[N - i - 1];\n        modulus_mod_n += params.modulus[N - i - 1];\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let diff = l - r;\n    let target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let is_equal_modulus: bool = diff == params.modulus;\n    let is_equal_zero: bool = diff.all(|elem| elem == 0);\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn is_zero<let N: u32, let MOD_BITS: u32>(val: [Field; N]) -> bool {\n    val.all(|limb| limb == 0)\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [Field; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = modulus[i] - val[i];\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    p_minus_self[0] += borrow_flags[0] as Field * TWO_POW_120;\n    for i in 1..N - 1 {\n        p_minus_self[i] += (borrow_flags[i] as Field * TWO_POW_120 - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= borrow_flags[N - 2] as Field;\n    validate_in_range::<_, MOD_BITS>(p_minus_self);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N - 1) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [Field; N], rhs: [Field; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (result, carry_flags, borrow_flags) = unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, MOD_BITS>(result);\n\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] - rhs[0] + addend[0] - result[0] - 1\n        + (borrow_flags[0] as Field - carry_flags[0] as Field) * TWO_POW_120;\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n        let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n        let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - prev_borrow_sub_carry\n            + borrow_sub_carry * TWO_POW_120;\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] - rhs[N - 1] + addend[N - 1]\n        - result[N - 1]\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __neg(params, val)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, borrow_flags) = unsafe { __neg_with_flags(params, val) };\n        validate_in_range::<_, MOD_BITS>(result);\n        let modulus = params.modulus;\n        let result_limb =\n            modulus[0] - val[0] - result[0] + (borrow_flags[0] as Field * TWO_POW_120);\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = modulus[i] - val[i] - result[i] - borrow_flags[i - 1] as Field\n                + (borrow_flags[i] as Field * TWO_POW_120);\n            assert(result_limb == 0);\n        }\n        let result_limb =\n            modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __add(params, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, carry_flags, borrow_flags, overflow_modulus) =\n            unsafe { __add_with_flags(params, lhs, rhs) };\n        validate_in_range::<_, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut subtrahend: [Field; N] = [0; N];\n        if (overflow_modulus) {\n            subtrahend = modulus;\n        }\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb =\n            lhs[0] + rhs[0] - subtrahend[0] - result[0] + borrow_sub_carry * TWO_POW_120;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] + rhs[i] - subtrahend[i] - result[i] - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb =\n            lhs[N - 1] + rhs[N - 1] - subtrahend[N - 1] - result[N - 1] - borrow_sub_carry;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __sub(params, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        // a - b = r\n        // p + a - b - r = 0\n        let (result, carry_flags, borrow_flags, underflow) =\n            unsafe { __sub_with_flags(params, lhs, rhs) };\n        validate_in_range::<_, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut addend: [Field; N] = [0; N];\n        if (underflow) {\n            addend = modulus;\n        }\n\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = lhs[0] - rhs[0] + addend[0] - result[0] + borrow_sub_carry * TWO_POW_120;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb =\n            lhs[N - 1] - rhs[N - 1] + addend[N - 1] - result[N - 1] - borrow_sub_carry;\n        assert(result_limb == 0);\n        result\n    }\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[lhs]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[result]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [lhs],\n            [true],\n        );\n    }\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n\n    if !std::runtime::is_unconstrained() {\n        // self / divisor = quotient rounded\n        // quotient * divisor + remainder - self = 0\n        evaluate_quadratic_expression(\n            params,\n            [[quotient]],\n            [[false]],\n            [[divisor]],\n            [[false]],\n            [numerator, remainder],\n            [true, false],\n        );\n        // we need (remainder < divisor)\n        // implies (divisor - remainder > 0)\n        validate_gt::<_, MOD_BITS>(divisor, remainder);\n    }\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/fns/constrained_ops.nr"},"97":{"source":"use crate::utils::split_bits;\n\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n * In this file:\n *\n * __compute_quadratic_expression_with_borrow_flags\n * __add_linear_expression\n * __compute_quadratic_expression_product\n * __compute_quadratic_expression\n * evaluate_quadratic_expression\n */\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\nunconstrained fn __compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N], [Field; 2 * N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let modulus: [Field; N] = params.modulus;\n    let modulus_bits = MOD_BITS;\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        modulus_bits,\n        modulus,\n        params.modulus_u60_x4,\n    );\n    assert(remainder == [0; N]);\n\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] * modulus[j];\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N] = [0; 2 * N];\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    let downshift: Field = 1 / two_pow_120;\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits = (mulout_p[0] - mulout_n[0] + (borrow_flags[0] * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n    flags: [bool; M],\n) -> ([Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [Field; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [Field; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + modulus2[j] - x[i][j];\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn __compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut add: [Field; N] = [0; N];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [Field; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] * rhs[k][j]);\n            }\n        }\n        mulout[i] += add[i];\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        k,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([Field; N], [Field; N], [Field; 2 * N]) = unsafe {\n        __compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [Field; N] = params.double_modulus;\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i];\n                    t0[k][i] += double_modulus[i];\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i];\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i];\n                    t1[k][i] += double_modulus[i];\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i];\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i];\n                t4[i] += double_modulus[i];\n            } else {\n                t4[i] += linear_terms[j][i];\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term = t0[k][i] * t1[k][j] - quotient[i] * params.modulus[j];\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j];\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] * params.modulus[j];\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/fns/expressions.nr"},"100":{"source":"use crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\nuse crate::fns::unconstrained_ops::{__add, __eq, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\n\nglobal TWO_POW_60: u64 = 0x1000000000000000;\n\n/**\n * In this file:\n *\n * __validate_in_field_compute_borrow_flags\n * __validate_gt_remainder\n * __neg_with_flags\n * __add_with_flags\n * __sub_with_flags\n * __barrett_reduction\n * __tonelli_shanks_sqrt\n */\n\npub(crate) unconstrained fn __from_field<let N: u32>(field: Field) -> [Field; N] {\n    // cast the field to a u60 representation\n    let res_u60: U60Repr<N, 2> = U60Repr::from_field(field);\n    let result: [Field; N] = U60Repr::into(res_u60);\n    result\n}\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [Field; N] = params.modulus;\n    flags[0] = modulus[0].lt(val[0]);\n    for i in 1..N - 1 {\n        flags[i] = modulus[i].lt(val[i] + flags[i - 1] as Field);\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N]) {\n    let a_u60: U60Repr<N, 2> = From::from(lhs);\n    let mut b_u60: U60Repr<N, 2> = From::from(rhs);\n\n    let underflow = b_u60.gte(a_u60);\n    assert(underflow == false, \"BigNum::validate_gt check fails\");\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 1;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            // Only set `borrow` and `carry` if they differ\n            if (carry != borrow) {\n                carry_flags[i / 2] = carry as bool;\n                borrow_flags[i / 2] = borrow as bool;\n            }\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> ([Field; N], [bool; N]) {\n    let x_u60: U60Repr<N, 2> = From::from(val);\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut borrow_in: u64 = 0;\n\n    let mut borrow_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let sub_term = x_u60.limbs[i] + borrow_in;\n        let borrow = (sub_term > params.modulus_u60.limbs[i]) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + params.modulus_u60.limbs[i] - sub_term;\n\n        borrow_in = borrow;\n        if ((i & 1) == 1) {\n            borrow_flags[i / 2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = From::from(lhs);\n    let b_u60: U60Repr<N, 2> = From::from(rhs);\n    let add_u60 = a_u60 + b_u60;\n\n    let overflow = add_u60.gte(params.modulus_u60);\n\n    let mut subtrahend_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    if overflow {\n        subtrahend_u60 = params.modulus_u60;\n    }\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + b_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = subtrahend_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            // Only set `borrow` and `carry` if they differ\n            if (carry != borrow) {\n                let idx = (i - 1) / 2;\n                carry_flags[idx] = carry as bool;\n                borrow_flags[idx] = borrow as bool;\n            }\n        }\n    }\n    let result = U60Repr::into(result_u60);\n\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let b_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let underflow = b_u60.gte(a_u60 + U60Repr::one());\n\n    let addend_u60: U60Repr<N, 2> = if underflow {\n        params.modulus_u60\n    } else {\n        U60Repr { limbs: [0; 2 * N] }\n    };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + addend_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            // Only set `borrow` and `carry` if they differ\n            if (carry != borrow) {\n                carry_flags[i / 2] = carry as bool;\n                borrow_flags[i / 2] = borrow as bool;\n            }\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [Field; 2 * N],\n    redc_param: [Field; N],\n    k: u32,\n    modulus: [Field; N],\n    modulus_u60: U60Repr<N, 4>,\n) -> ([Field; N], [Field; N]) {\n    // for each i in 0..(N + N), adds x[i] * redc_param[j] to mulout[i + j] for each j in 0..N\n    let mut mulout: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout[i + j] += x[i] * redc_param[j];\n        }\n    }\n\n    mulout = split_bits::__normalize_limbs(mulout, 3 * N - 1);\n    let mulout_u60: U60Repr<N, 6> = U60Repr::new(mulout);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient_u60 = mulout_u60.shr((k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = quotient_u60.into_field_array();\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] += partial_quotient_full[i] * modulus[j];\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    for i in 0..(N + N) {\n        let (lo, hi) = split_bits::split_120_bits(quotient_mul_modulus_normalized[i]);\n        quotient_mul_modulus_normalized[i] = lo;\n\n        // Propagate higher bits to the next index\n        // TODO: what is faster, leaving this if statement in or out?\n        // (array is size-1 too large so we can tolerate adding 0 into max element)\n        if (i + 1 < N + N) {\n            quotient_mul_modulus_normalized[i + 1] += hi;\n        }\n    }\n\n    let quotient_mul_modulus_u60: U60Repr<N, 4> = U60Repr::new(quotient_mul_modulus_normalized);\n    // convert the input into U60Repr\n    let x_u60: U60Repr<N, 4> = U60Repr::new(x);\n    let mut remainder_u60 = x_u60 - quotient_mul_modulus_u60;\n    // barrett reduction is quirky so might need to remove a few modulus_u60 from the remainder\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n\n    let q: [Field; N] = U60Repr::into(quotient_u60);\n    let r: [Field; N] = U60Repr::into(remainder_u60);\n\n    (q, r)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut target: U60Repr<N, 2> = params.modulus_u60 - U60Repr::one();\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target.limbs[0] & 1) == 1;\n        if (lsb_is_one) {\n            break;\n        }\n        result += 1;\n        target.shr1();\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [Field; N],\n    p_minus_one_over_two: [Field; N],\n) -> (bool, [Field; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [Field; N] = __one();\n    let neg_one = __neg(params, one);\n    let found = __eq(exped, neg_one);\n    let mut result: (bool, [Field; N]) = (found, target);\n    if (!found) {\n        let _target = __add(params, target, one);\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [Field; N] {\n    let mut target: [Field; N] = __one();\n    let p_minus_one_over_two: U60Repr<N, 2> = (params.modulus_u60 - U60Repr::one()).shr(1);\n    let p_minus_one_over_two: [Field; N] = U60Repr::into(p_minus_one_over_two);\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [Field; N],\n    i: u32,\n) -> u32 {\n    let one: [Field; N] = __one();\n    let is_one = __eq(t2m, one);\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/fns/unconstrained_helpers.nr"},"101":{"source":"use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __multiplicative_generator, __primitive_root_log_size,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\n/**\n * In this file:\n *\n * __one\n * __derive_from_seed\n * __eq\n * __is_zero\n * __neg\n * __add\n * __sub\n * __mul_with_quotient\n * __mul\n * __div\n * __udiv_mod\n * __invmod\n * __pow\n * __batch_invert\n * __batch_invert_slice\n */\n\npub(crate) unconstrained fn __one<let N: u32>() -> [Field; N] {\n    let mut limbs: [Field; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [Field; N], rhs: [Field; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [Field; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    limbs: [Field; N],\n) -> [Field; N] {\n    let f: [Field; N] = limbs;\n    let x_u60: U60Repr<N, 2> = U60Repr::from(f);\n    U60Repr::into(params.modulus_u60 - x_u60)\n}\n\npub(crate) unconstrained fn __add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let x_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let y_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let mut z_u60 = x_u60 + y_u60;\n\n    if z_u60.gte(params.modulus_u60) {\n        z_u60 = z_u60 - params.modulus_u60;\n    }\n    U60Repr::into(z_u60)\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    __add(params, lhs, __neg(params, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += lhs[i] * rhs[j];\n        }\n    }\n    let to_reduce = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(\n        to_reduce,\n        params.redc_param,\n        MOD_BITS,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    let inv_divisor = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut quotient_u60: U60Repr<N, 2> = U60Repr::from([0; N]);\n    let mut remainder_u60: U60Repr<N, 2> = U60Repr::from(numerator);\n\n    let mut divisor_u60: U60Repr<N, 2> = U60Repr::from(divisor);\n    let b = divisor_u60;\n\n    let numerator_msb = remainder_u60.get_msb();\n    let divisor_msb = divisor_u60.get_msb();\n    if divisor_msb > numerator_msb {\n        ([0; N], numerator)\n    } else {\n        let mut bit_difference = remainder_u60.get_msb() - divisor_u60.get_msb();\n\n        let mut accumulator_u60: U60Repr<N, 2> = U60Repr::one();\n        divisor_u60 = divisor_u60.shl(bit_difference);\n        accumulator_u60 = accumulator_u60.shl(bit_difference);\n\n        if (divisor_u60.gte(remainder_u60 + U60Repr::one())) {\n            divisor_u60.shr1();\n            accumulator_u60.shr1();\n        }\n        for _ in 0..(N * 120) {\n            if (remainder_u60.gte(b) == false) {\n                break;\n            }\n\n            // we've shunted 'divisor' up to have the same bit length as our remainder.\n            // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n            if (remainder_u60.gte(divisor_u60)) {\n                remainder_u60 -= divisor_u60;\n                // we can use OR here instead of +, as\n                // accumulator is always a nice power of two\n                quotient_u60 = quotient_u60 + accumulator_u60;\n            }\n            divisor_u60.shr1(); // >>= 1;\n            accumulator_u60.shr1(); //  >>= 1;\n        }\n\n        (U60Repr::into(quotient_u60), U60Repr::into(remainder_u60))\n    }\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    let one_u60: U60Repr<N, 2> = U60Repr::one();\n    let exp_u60 = params.modulus_u60 - (one_u60 + one_u60);\n    let exp = U60Repr::into(exp_u60);\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n    exponent: [Field; N],\n) -> [Field; N] {\n    let x: U60Repr<N, 2> = U60Repr::from(exponent);\n\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [Field; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if x.get_bit(num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n) -> [[Field; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut temporaries: [[Field; N]; M] = std::mem::zeroed();\n    for i in 0..M {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[Field; N]; M] = [[0; N]; M];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..M {\n        let idx = M - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]],\n) -> [[Field; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut temporaries: [[Field; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[Field; N]] = [];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result = result.push_front(T0);\n        } else {\n            result = result.push_front([0; N]);\n        };\n    }\n\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [Field; N],\n) -> std::option::Option<[Field; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one_u60: U60Repr<N, 2> = U60Repr::one();\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let mut Q = (params.modulus_u60 - one_u60).shr(primitive_root_log_size - 1);\n    let Q_minus_one_over_two_u60 = (Q - one_u60).shr(2);\n    let Q_minus_one_over_two: [Field; N] = U60Repr::into(Q_minus_one_over_two_u60);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [Field; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut result = Option::none();\n    let one: [Field; N] = __one::<N>();\n    if (__eq(check, one)) {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/fns/unconstrained_ops.nr"},"104":{"source":"use crate::params::BigNumParams;\nuse crate::utils::map::map;\n\nuse crate::fns::{\n    constrained_ops::{\n        add, assert_is_not_equal, conditional_select, derive_from_seed, div, eq, is_zero, mul, neg,\n        sub, udiv, udiv_mod, umod, validate_in_field, validate_in_range,\n    },\n    expressions::{__compute_quadratic_expression, evaluate_quadratic_expression},\n    serialization::{from_be_bytes, to_le_bytes},\n    unconstrained_ops::{\n        __add, __batch_invert, __batch_invert_slice, __derive_from_seed, __div, __eq, __invmod,\n        __is_zero, __mul, __neg, __pow, __sub, __tonelli_shanks_sqrt, __udiv_mod,\n    },\n};\nuse std::ops::{Add, Div, Mul, Neg, Sub};\n\npub struct RuntimeBigNum<let N: u32, let MOD_BITS: u32> {\n    pub limbs: [Field; N],\n    pub params: BigNumParams<N, MOD_BITS>,\n}\n\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNum<N, MOD_BITS> {}\n\n// All functions prefixed `__` are unconstrained!\n// They're not actually decorated as `unconstrained` because to return the `params` (as part of Self) from an `unconstrained` fn would cause range constraints. Instead, each `__` fn wraps a call to an unconstrained fn, so that the already-range-constrained `params` can be inserted into Self after the unconstrained call.\npub(crate) trait RuntimeBigNumTrait<let N: u32, let MOD_BITS: u32>: Neg + Add + Sub + Mul + Div + Eq {\n    fn new(params: BigNumParams<N, MOD_BITS>) -> Self;\n    fn one(params: BigNumParams<N, MOD_BITS>) -> Self;\n    fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self;\n    unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self;\n    fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [Field]) -> Self;\n    fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [Field; N]) -> Self;\n    fn from_be_bytes<let NBytes: u32>(params: BigNumParams<N, MOD_BITS>, x: [u8; NBytes]) -> Self;\n\n    fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes];\n\n    fn modulus(self) -> Self;\n    fn modulus_bits() -> u32;\n    fn num_limbs() -> u32;\n    // pub fn get(self) -> [Field];\n    fn get_limbs(self) -> [Field; N];\n    fn get_limb(self, idx: u32) -> Field;\n    fn set_limb(&mut self, idx: u32, value: Field);\n\n    unconstrained fn __eq(self, other: Self) -> bool;\n    unconstrained fn __is_zero(self) -> bool;\n\n    // unconstrained\n    fn __neg(self) -> Self;\n    // unconstrained\n    fn __add(self, other: Self) -> Self;\n    // unconstrained\n    fn __sub(self, other: Self) -> Self;\n    // unconstrained\n    fn __mul(self, other: Self) -> Self;\n    // unconstrained\n    fn __div(self, other: Self) -> Self;\n    // unconstrained\n    fn __udiv_mod(self, divisor: Self) -> (Self, Self);\n    // unconstrained\n    fn __invmod(self) -> Self;\n    // unconstrained\n    fn __pow(self, exponent: Self) -> Self;\n\n    // unconstrained\n    fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M];\n    unconstrained fn __batch_invert_slice<let M: u32>(to_invert: [Self]) -> [Self];\n\n    fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self>;\n\n    // unconstrained\n    fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self);\n\n    fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    );\n\n    fn eq(lhs: Self, rhs: Self) -> bool {\n        lhs == rhs\n    }\n    fn assert_is_not_equal(self, other: Self);\n    fn validate_in_field(self);\n    fn validate_in_range(self);\n    // pub fn validate_gt(self, lhs: Self, rhs: Self);\n\n    fn udiv_mod(numerator: Self, divisor: Self) -> (Self, Self);\n    fn udiv(numerator: Self, divisor: Self) -> Self;\n    fn umod(numerator: Self, divisor: Self) -> Self;\n\n    fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self;\n    fn is_zero(self) -> bool;\n}\n\nimpl<let N: u32, let MOD_BITS: u32> Neg for RuntimeBigNum<N, MOD_BITS> {\n    fn neg(self) -> Self {\n        let params = self.params;\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNumTrait<N, MOD_BITS> for RuntimeBigNum<N, MOD_BITS> {\n\n    fn new(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let limbs: [Field; N] = [0; N];\n        Self { limbs, params }\n    }\n\n    fn one(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let mut result = RuntimeBigNum::new(params);\n        result.limbs[0] = 1;\n        result\n    }\n\n    fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = __derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [Field]) -> Self {\n        Self { limbs: limbs.as_array(), params }\n    }\n\n    fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [Field; N]) -> Self {\n        Self { limbs, params }\n    }\n\n    fn from_be_bytes<let NBytes: u32>(params: BigNumParams<N, MOD_BITS>, x: [u8; NBytes]) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS, _>(x), params }\n    }\n\n    fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes] {\n        to_le_bytes::<_, MOD_BITS, _>(self.limbs)\n    }\n\n    fn modulus(self) -> Self {\n        let params = self.params;\n        Self { limbs: params.modulus, params }\n    }\n\n    fn modulus_bits() -> u32 {\n        MOD_BITS\n    }\n\n    fn num_limbs() -> u32 {\n        N\n    }\n\n    // fn get(self) -> [Field] {\n    //     self.get_limbs()\n    // }\n\n    fn get_limbs(self) -> [Field; N] {\n        self.limbs\n    }\n\n    fn get_limb(self, idx: u32) -> Field {\n        self.limbs[idx]\n    }\n\n    fn set_limb(&mut self, idx: u32, value: Field) {\n        self.limbs[idx] = value;\n    }\n\n    unconstrained fn __eq(self, other: Self) -> bool {\n        assert(self.params == other.params);\n        __eq(self.limbs, other.limbs)\n    }\n\n    unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __neg(self) -> Self {\n        let params = self.params;\n        let limbs = unsafe { __neg(params, self.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __add(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __sub(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __mul::<_, MOD_BITS>(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        let limbs = unsafe { __div::<_, MOD_BITS>(params, self.limbs, divisor.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = unsafe { __udiv_mod(self.limbs, divisor.limbs) };\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __invmod(self) -> Self {\n        let params = self.params;\n        assert(params.has_multiplicative_inverse);\n        let limbs = unsafe { __invmod::<_, MOD_BITS>(params, self.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __pow(self, exponent: Self) -> Self {\n        let params = self.params;\n        assert(params == exponent.params);\n        let limbs = unsafe { __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs =\n            unsafe { __batch_invert::<_, MOD_BITS, _>(params, x.map(|bn| Self::get_limbs(bn))) };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // Note: can't return a slice from this unconstrained to a constrained function.\n    unconstrained fn __batch_invert_slice<let M: u32>(x: [Self]) -> [Self] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs = {\n            let inv_slice =\n                __batch_invert_slice::<_, MOD_BITS>(params, x.map(|bn| Self::get_limbs(bn)));\n            inv_slice.as_array()\n        };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = self.params;\n        let maybe_limbs = unsafe { __tonelli_shanks_sqrt(params, self.limbs) };\n        maybe_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self) {\n        let (q_limbs, r_limbs) = unsafe {\n            __compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n                params,\n                map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                lhs_flags,\n                map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                rhs_flags,\n                map(linear_terms, |bn| Self::get_limbs(bn)),\n                linear_flags,\n            )\n        };\n        (Self { limbs: q_limbs, params }, Self { limbs: r_limbs, params })\n    }\n\n    fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) {\n        evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            rhs_flags,\n            map(linear_terms, |bn| Self::get_limbs(bn)),\n            linear_flags,\n        )\n    }\n\n    fn validate_in_field(self: Self) {\n        let params = self.params;\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    fn validate_in_range(self) {\n        validate_in_range::<_, MOD_BITS>(self.limbs);\n    }\n\n    fn assert_is_not_equal(self, other: Self) {\n        let params = self.params;\n        assert(params == other.params);\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    fn udiv(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    fn umod(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self {\n        let params = lhs.params;\n        assert(params == rhs.params);\n        Self { limbs: conditional_select(lhs.limbs, rhs.limbs, predicate), params }\n    }\n\n    fn is_zero(self) -> bool {\n        is_zero::<N, MOD_BITS>(self.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Add for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Sub for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Mul for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Div for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for RuntimeBigNum<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        let params = self.params;\n        assert(params == other.params);\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/runtime_bignum.nr"},"110":{"source":"/// Multiple entires in the `MUL_DE_BRUIJN_BIT` list do not map to a valid output of `v * 0x6c04f118e9966f6b`.\n/// This is a dummy value to fill the gaps in the map.\nglobal n1: u32 = 0xffffffff;\n\nglobal MUL_DE_BRUIJN_BIT: [u32; 128] = [\n    0, // change to 1 if you want bitSize(0) = 1\n    48, n1, n1, 31, n1, 15, 51, n1, 63, 5, n1, n1, n1, 19, n1, 23, 28, n1, n1, n1, 40, 36, 46, n1,\n    13, n1, n1, n1, 34, n1, 58, n1, 60, 2, 43, 55, n1, n1, n1, 50, 62, 4, n1, 18, 27, n1, 39, 45,\n    n1, n1, 33, 57, n1, 1, 54, n1, 49, n1, 17, n1, n1, 32, n1, 53, n1, 16, n1, n1, 52, n1, n1, n1,\n    64, 6, 7, 8, n1, 9, n1, n1, n1, 20, 10, n1, n1, 24, n1, 29, n1, n1, 21, n1, 11, n1, n1, 41, n1,\n    25, 37, n1, 47, n1, 30, 14, n1, n1, n1, n1, 22, n1, n1, 35, 12, n1, n1, n1, 59, 42, n1, n1, 61,\n    3, 26, 38, 44, n1, 56,\n];\n\npub unconstrained fn get_msb64(x: u64) -> u32 {\n    let mut v = x;\n    v |= v >> 1;\n    v |= v >> 2;\n    v |= v >> 4;\n    v |= v >> 8;\n    v |= v >> 16;\n    v |= v >> 32;\n    MUL_DE_BRUIJN_BIT[(std::wrapping_mul(v, 0x6c04f118e9966f6b)) >> 57]\n}\n\n// 1100\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/utils/msb.nr"},"111":{"source":"global TWO_POW_56: u64 = 0x100000000000000;\npub(crate) global TWO_POW_60: u64 = 0x1000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n//fields to u60rep conversion\n// field elements are 254 bits\n// so there will be 5 limbs\npub(crate) unconstrained fn field_to_u60rep(mut x: Field) -> (u64, u64, u64, u64, u64) {\n    // get the first 60 bits by casting to u64 and then taking the lower 60 bits\n    // we use the fact that this casting drops everything above 64 bits\n    let x_first_u64 = (x as u64);\n    let first: u64 = x_first_u64 % TWO_POW_60;\n    // this becomes the same as a integer division because we're removing the remainder\n    x = (x - (first as Field)) / (TWO_POW_60 as Field);\n    let x_second_u64 = (x as u64);\n    let second = x_second_u64 % TWO_POW_60;\n    x = (x - (second as Field)) / (TWO_POW_60 as Field);\n    let x_third_u64 = (x as u64);\n    let third = x_third_u64 % TWO_POW_60;\n    x = (x - (third as Field)) / (TWO_POW_60 as Field);\n    let x_fourth_u64 = (x as u64);\n    let fourth = x_fourth_u64 % TWO_POW_60;\n    x = (x - (fourth as Field)) / (TWO_POW_60 as Field);\n    let x_fifth_u64 = (x as u64);\n    let fifth = x_fifth_u64 % TWO_POW_60;\n    (first, second, third, fourth, fifth)\n}\n\n// Decomposes a single field into two 120 bit fields\npub unconstrained fn split_120_bits(mut x: Field) -> (Field, Field) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_56 = ((x as u64) % TWO_POW_56) as Field;\n\n    let low = low_lower_64 + TWO_POW_64 * low_upper_56;\n    let high = (x - low_upper_56) / TWO_POW_56 as Field;\n\n    (low, high)\n}\n\n/// Decomposes a single field into two 60 bit fields\n///\n/// Expects the input limb to be in the range [0, ..., 2^{120 - 1}]\nunconstrained fn __split_60_bits(x: Field) -> (u64, u64) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let x_lower_64 = (x as u64);\n    let low = x_lower_64 % TWO_POW_60;\n    let high = ((x - (low as Field)) / TWO_POW_60 as Field) as u64;\n\n    (low, high)\n}\n\n/// Decomposes a single field into two 60 bit fields\n///\n/// Expects the input limb to be in the range [0, ..., 2^{120 - 1}]\npub fn split_60_bits(x: Field) -> (u64, u64) {\n    // We assert that the two returned limbs fit within 60 bits each\n    // and reconstruct `x` when added together.\n    let (lo, hi) = unsafe { __split_60_bits(x) };\n    if !std::runtime::is_unconstrained() {\n        let lo_field = lo as Field;\n        let hi_field = hi as Field;\n        lo_field.assert_max_bit_size::<60>();\n        hi_field.assert_max_bit_size::<60>();\n        assert_eq(lo_field + (TWO_POW_60 as Field) * hi_field, x);\n    }\n\n    (lo, hi)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [Field; N] {\n    let mut normalized: [Field; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(next);\n\n        normalized[i] = lo;\n        next = input[i + 1] + hi;\n    }\n    {\n        let (lo, hi) = split_120_bits(next);\n        normalized[range - 1] = lo;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/utils/split_bits.nr"},"112":{"source":"use crate::utils::msb::get_msb64;\nuse crate::utils::split_bits;\nuse crate::utils::split_bits::{field_to_u60rep, TWO_POW_60};\n\n/**\n * @brief U60Repr represents a BigNum element as a sequence of 60-bit unsigned integers.\n *\n * @description: used in unconstrained functions when computing witness values.\n * It is helpful to use u60 types when evaluating addition operations that can overflow the field modulus,\n * as well as when performing bit shifts.\n */\npub struct U60Repr<let N: u32, let NumSegments: u32> {\n    pub(crate) limbs: [u64; N * NumSegments],\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Add for U60Repr<N, NumSegments> {\n    fn add(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut carry: u64 = 0;\n        for i in 0..N * NumSegments {\n            let mut add: u64 = self.limbs[i] + b.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            result.limbs[i] = add;\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Sub for U60Repr<N, NumSegments> {\n    fn sub(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut borrow: u64 = 0;\n        let mut borrow_in: u64 = 0;\n\n        for i in 0..N * NumSegments {\n            borrow = ((b.limbs[i] + borrow_in) > self.limbs[i]) as u64;\n            let sub = (borrow << 60) + self.limbs[i] - b.limbs[i] - borrow_in;\n            result.limbs[i] = sub;\n            borrow_in = borrow;\n        }\n\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::convert::From<[Field; N]> for U60Repr<N, NumSegments> {\n    fn from(input: [Field; N]) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..N {\n            let (lo, hi) = split_bits::split_60_bits(input[i]);\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n}\n\n// impl<let N: u32, let NumSegments: u32> std::convert::From<Field> for U60Repr<N, NumSegments> {\n//     fn from(input: Field) -> Self {\n//        let (low, mid, high) =  unsafe { field_to_u60rep(input) } ;\n//         let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n//         let N_u60: u32 = N * NumSegments;\n//         assert(N_u60 >=1, \"N must be at least 1\");\n//         if N_u60 == 1 {\n//             assert((mid ==0) & (high == 0), \"input field is too large to fit in a single limb\");\n//             result.limbs[0] = low;\n//         }\n//         else if N_u60 == 2{\n//             assert(high == 0, \"input field is too large to fit in two limbs\");\n//             result.limbs[0] = low;\n//             result.limbs[1] = mid;\n//         }else{\n//             result.limbs[0] = low;\n//             result.limbs[1] = mid;\n//             result.limbs[2] = high;\n//         }\n//         result\n//     }\n// }\n\nimpl<let N: u32, let NumSegments: u32> std::convert::Into<[Field; N]> for U60Repr<N, NumSegments> {\n    fn into(x: U60Repr<N, NumSegments>) -> [Field; N] {\n        let mut result: [Field; N] = [0; N];\n        let two_pow_60: Field = 0x1000000000000000;\n        for i in 0..N {\n            result[i] = x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * two_pow_60);\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::cmp::Eq for U60Repr<N, NumSegments> {\n    fn eq(self, other: Self) -> bool {\n        self.limbs == other.limbs\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> U60Repr<N, NumSegments> {\n\n    pub(crate) fn new<let NumFieldSegments: u32>(x: [Field; N * NumFieldSegments]) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..(N * NumFieldSegments) {\n            let (lo, hi) = split_bits::split_60_bits(x[i]);\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n\n    pub(crate) fn one() -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub(crate) unconstrained fn from_field(input: Field) -> Self {\n        let (first, second, third, fourth, fifth) = field_to_u60rep(input);\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        let N_u60: u32 = N * NumSegments;\n        assert(N_u60 >= 1, \"N must be at least 1\");\n        if N_u60 == 1 {\n            assert(\n                (second == 0) & (third == 0) & (fourth == 0) & (fifth == 0),\n                \"input field is too large to fit in a single limb\",\n            );\n            result.limbs[0] = first;\n        } else if N_u60 == 2 {\n            assert(\n                (third == 0) & (fourth == 0) & (fifth == 0),\n                \"input field is too large to fit in two limbs\",\n            );\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n        } else if N_u60 == 3 {\n            assert((fourth == 0) & (fifth == 0), \"input field is too large to fit in three limbs\");\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n        } else if N_u60 == 4 {\n            assert((fifth == 0), \"input field is too large to fit in four limbs\");\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n            result.limbs[3] = fourth;\n        } else {\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n            result.limbs[3] = fourth;\n            result.limbs[4] = fifth;\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn into_field_array(\n        x: U60Repr<N, NumSegments>,\n    ) -> [Field; N * NumSegments / 2] {\n        let mut result: [Field; N * NumSegments / 2] = [0; N * NumSegments / 2];\n        for i in 0..(N * NumSegments / 2) {\n            result[i] =\n                x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * TWO_POW_60 as Field);\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn gte(self, b: Self) -> bool {\n        let mut result = false;\n        let mut early_exit = false;\n        for i in 0..(N * NumSegments) {\n            let idx = (N * NumSegments) - 1 - i;\n            if (b.limbs[idx] == self.limbs[idx]) {\n                continue;\n            }\n\n            result = b.limbs[idx] < self.limbs[idx];\n            early_exit = true;\n            break;\n        }\n        if early_exit {\n            result\n        } else {\n            self.limbs[0] == b.limbs[0]\n        }\n    }\n\n    pub(crate) fn get_bit(self, bit: u32) -> bool {\n        let segment_index = bit / 60;\n        let uint_index = bit % 60;\n\n        let limb: u64 = self.limbs[segment_index];\n        let value = (limb >> uint_index as u8) & 1;\n        value == 1\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = (shift % 60) as u8;\n        let remainder_shift = (60 - limb_shift) as u8;\n        let mask: u64 = (((1 as u64) << limb_shift) - 1) << remainder_shift;\n        result.limbs[0] = (self.limbs[0 + num_shifted_limbs] >> limb_shift);\n\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i + num_shifted_limbs];\n            result.limbs[i] = value >> limb_shift;\n            let remainder: u64 = (value << remainder_shift) & mask;\n            result.limbs[i - 1] = result.limbs[i - 1] + remainder;\n        }\n        result\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr1(&mut self) {\n        let mut remainder = 0;\n\n        for i in 0..N * NumSegments {\n            let value = self.limbs[N * NumSegments - 1 - i];\n            self.limbs[N * NumSegments - 1 - i] = (value >> 1) + remainder;\n            remainder = (value & 1) << 59;\n        }\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shl(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; NumSegments * N] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = (shift % 60) as u8;\n        let remainder_shift: u8 = 60 - limb_shift as u8;\n\n        // 83\n        // limb shift = 1\n        // inside shift = 19 bits to the left\n        // meaning we have 19 carry bits and 41 remainder bits\n        let mask: u64 = (1 as u64 << 60) - 1;\n        //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n        let value = self.limbs[0];\n\n        let mut remainder = (value >> remainder_shift);\n        result.limbs[num_shifted_limbs] = (value << limb_shift) & mask;\n\n        // shift 84. num shifted = 1\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i];\n            let upshift = ((value << limb_shift) + remainder) & mask;\n            result.limbs[i + num_shifted_limbs] = upshift;\n            remainder = (value >> remainder_shift);\n            // let remainder: u64 = (self.limbs.get(i + num_shifted_limbs as u64) << remainder_shift as u8) & mask;\n            // result.limbs.set(i - 1, result.limbs.get(i - 1) + remainder);\n        }\n        result\n    }\n\n    pub(crate) fn increment(&mut self) {\n        let mut carry: u64 = 0;\n\n        let mut add: u64 = self.limbs[0] + 1;\n        carry = add >> 60;\n        add = add - (carry << 60);\n        self.limbs[0] = add;\n\n        for i in 1..NumSegments * N {\n            let mut add: u64 = self.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            self.limbs[i] = add;\n        }\n    }\n\n    pub(crate) unconstrained fn get_msb(val: Self) -> u32 {\n        let mut count = 0;\n        for i in 0..N * NumSegments {\n            let v = val.limbs[((N * NumSegments) - 1 - i)];\n            if (v > 0) {\n                count = 60 * ((N * NumSegments) - 1 - i) + get_msb64(v);\n                break;\n            }\n        }\n        count\n    }\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/utils/u60_representation.nr"},"114":{"source":"use dep::bignum::{params::BigNumParams, RuntimeBigNum};\n\npub fn encrypt<let Tau: u32, let Num: u32, let Bits: u32>(\n    params: BigNumParams<Num, Bits>,\n    key_set: [[Field; Num]; Tau],\n    entropy: [bool; Tau],\n    message: bool,\n) -> RuntimeBigNum<Num, Bits> {\n    let mut terms = &[];\n    for i in 0..Tau {\n        terms = terms.push_back(\n            if entropy[i] {\n                RuntimeBigNum::from_array(params, key_set[i])\n            } else {\n                RuntimeBigNum::new(params)\n            },\n        );\n    }\n    let mut sum = unsafe { terms.reduce(|sum, next| sum.__add(next)) };\n\n    let mut flags = [false; Tau + 1];\n    terms = terms.push_back(sum);\n    flags[Tau] = true;\n\n    RuntimeBigNum::evaluate_quadratic_expression(\n        params,\n        [[]; 0],\n        [[]; 0],\n        [[]; 0],\n        [[]; 0],\n        terms.as_array(),\n        flags,\n    );\n\n    if message {\n        let _1 = RuntimeBigNum::one(params);\n        let _2 = _1 + _1;\n        sum += RuntimeBigNum::from_array(params, key_set[0]).udiv(_2);\n    }\n    sum\n}\n\npub fn decrypt<let Limbs: u32, let Bits: u32>(\n    decryption_key: RuntimeBigNum<Limbs, Bits>,\n    ciphertext: RuntimeBigNum<Limbs, Bits>,\n) -> bool {\n    let _1 = RuntimeBigNum::one(ciphertext.params);\n    let _2 = _1 + _1;\n\n    let k = decryption_key;\n    let c = ciphertext;\n\n    // round_nearest(2*c/k)%2 == 1\n    (c.udiv(k) * _2 + (k.udiv(_2) + c.umod(k) * _2).udiv(k)).umod(_2) == _1\n}\n\n#[test]\nfn test_encrypt_decrypt() {\n    let dec_key_limbs = [1, 4, 2, 8, 5, 7, 0, 0, 0];\n    let dec_key = RuntimeBigNum::from_array(MC1031_params, dec_key_limbs);\n    let enc_key = [dec_key_limbs; 1289 + 1];\n    let mut entropy = [false; 1289 + 1];\n    for i in 0..123 {\n        entropy[(i * 456) % 1289 + 1] = true;\n    }\n\n    assert(decrypt(dec_key, encrypt(MC1031_params, enc_key, entropy, true)) == true);\n    assert(decrypt(dec_key, encrypt(MC1031_params, enc_key, entropy, false)) == false);\n}\n\n/* Old implementations using BigNums fixed since compile time */\n// TODO: cleaning up and refactoring in progress\n\n/*\nfn decrypt_noise(p: AGCD, c: AGCD) -> AGCD {\n    let _1: AGCD = BigNum::one();\n    let _2 = _1 + _1;\n\n    // ~ c%(p/2)\n    c.umod(p.udiv(_2))\n}\n\n\n\n// (Harcoded for security parameter=128)\npub fn validate_keypair<let Tau: u32>(\n    common_divisor_entropy: [Field; 8],\n    multiplier_entropy: [[Field; 2]; Tau + 1],\n    additive_entropy: [[Field; 2]; Tau + 1],\n    resulting_samples: [[Field; 9]; Tau + 1],\n) {\n    // Assert that p has 128*7 bits or less\n    let TWO_POW_120 = 0x1_00000_00000_00000_00000_00000_00000;\n    for i in 0..7 {\n        assert(common_divisor_entropy[i].lt(TWO_POW_120));\n    }\n    let TWO_POW_56 = 0x10000_00000_00000;\n    assert(common_divisor_entropy[7].lt(TWO_POW_56));\n\n    let mut decryption_key_limbs = [0; 9];\n    for i in 0..8 {\n        decryption_key_limbs[i] = common_divisor_entropy[i];\n    }\n    let decryption_key: MC1031 = BigNum::from_slice(decryption_key_limbs);\n\n    for i in 0..Tau + 1 {\n        // Assert that q's have 128+7 bits or less\n        assert(multiplier_entropy[i][0].lt(TWO_POW_120));\n        assert(multiplier_entropy[i][1].lt((2 << 15) as Field));\n\n        // Assert that r's have 128 bits or less\n        assert(additive_entropy[i][0].lt(TWO_POW_120));\n        assert(additive_entropy[i][1].lt((2 << 8) as Field));\n\n        let mut multiplier_limbs = [0; 9];\n        multiplier_limbs[0] = multiplier_entropy[i][0];\n        multiplier_limbs[1] = multiplier_entropy[i][1];\n        let multiplier = BigNum::from_slice(multiplier_limbs);\n\n        let mut added_noise_limbs = [0; 9];\n        added_noise_limbs[0] = additive_entropy[i][0];\n        added_noise_limbs[1] = additive_entropy[i][1];\n        let added_noise = BigNum::from_slice(added_noise_limbs);\n        let TWO_POW_127 = BigNum::from_slice([0, 0x80, 0, 0, 0, 0, 0, 0, 0]);\n\n        assert(\n            resulting_samples[i] == (decryption_key * multiplier + added_noise - TWO_POW_127).limbs,\n        );\n    }\n}\n*/\n\n/*\n#[test]\nfn uniform_noise_potential_detector() {\n    let _1: AGCD = BigNum::one();\n    let _2 = _1 + _1;\n\n    let dk = BigNum::from_slice([1, 4, 2, 8, 5, 7, 0, 0, 0]);\n    let ek = [dk + _1; OLD_TAU];\n    let mut entropy = [false; OLD_TAU];\n    for i in 0..15 {\n        entropy[(i * 7) % OLD_TAU] = true;\n    }\n    let real_noise = decrypt_noise(dk, encrypt(ek, entropy, true));\n    let fake_noise = decrypt_noise(dk, BigNum::from_slice([4, 4, 6, 2, 6, 7, 4, 2, 2]));\n    println(f\"real_noise: {real_noise}\");\n    println(f\"fake_noise: {fake_noise}\");\n}\n*/\n\n// Maximum Cyphertext considered (integers modulo 2^1031)\nglobal MC1031_params: BigNumParams<9, 1031> = BigNumParams {\n    modulus: [\n        0xffffffffffffffffffffffffffffff,\n        0xffffffffffffffffffffffffffffff,\n        0xffffffffffffffffffffffffffffff,\n        0xffffffffffffffffffffffffffffff,\n        0xffffffffffffffffffffffffffffff,\n        0xffffffffffffffffffffffffffffff,\n        0xffffffffffffffffffffffffffffff,\n        0xffffffffffffffffffffffffffffff,\n        0x7fffffffffffffffff,\n    ],\n    double_modulus: [\n        0x01fffffffffffffffffffffffffffffe,\n        0x01fffffffffffffffffffffffffffffe,\n        0x01fffffffffffffffffffffffffffffe,\n        0x01fffffffffffffffffffffffffffffe,\n        0x01fffffffffffffffffffffffffffffe,\n        0x01fffffffffffffffffffffffffffffe,\n        0x01fffffffffffffffffffffffffffffe,\n        0x01fffffffffffffffffffffffffffffe,\n        0xfffffffffffffffffe,\n    ],\n    modulus_u60: U60Repr {\n        limbs: [\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x07ff,\n        ],\n    },\n    modulus_u60_x4: U60Repr {\n        limbs: [\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x07ff,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n        ],\n    },\n    redc_param: [0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08000000000000000000],\n    has_multiplicative_inverse: false,\n};\nuse dep::bignum::utils::u60_representation::U60Repr;\n","path":"/root/aztec-grant-pss/libs/cheon_stehle/src/lib.nr"}},"names":["main"],"brillig_names":["decompose_hint","__add_with_flags","__udiv_mod","__compute_quadratic_expression_with_borrow_flags","__validate_gt_remainder","__mul","__compute_quadratic_expression_with_borrow_flags","__sub_with_flags","output_detect","output_board","directive_invert"]}