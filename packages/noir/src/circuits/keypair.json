{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":10754473920813016778,"abi":{"parameters":[{"name":"common_divisor","type":{"kind":"array","length":8,"type":{"kind":"field"}},"visibility":"private"},{"name":"scaling_factors","type":{"kind":"array","length":1,"type":{"kind":"array","length":2,"type":{"kind":"field"}}},"visibility":"private"},{"name":"additive_noises","type":{"kind":"array","length":1,"type":{"kind":"array","length":2,"type":{"kind":"field"}}},"visibility":"private"},{"name":"resulting_samples","type":{"kind":"array","length":1,"type":{"kind":"array","length":9,"type":{"kind":"field"}}},"visibility":"public"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"6":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"18":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        /*@safety: borrow is enforced to be boolean due to its type.\n            if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n            if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n        */\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            /*@safety: decomposition is properly checked below*/\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            unsafe {\n                //@safety: already unconstrained\n                field_less_than(b, a)\n            },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            //@safety: unsafe in unconstrained\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        unsafe {\n            //@safety: Take a hint of the comparison and verify it\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"19":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            //@safety : unconstrained context\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"21":{"source":"pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        //@safety : xlo and xhi decomposition is checked below\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"62":{"source":"global Tau: u32 = 0;//289;\n\n// TODO: parametrize dependent on security parameter (using comptime calculations)\n\nfn main(\n    common_divisor: [Field; 8],\n    scaling_factors: [[Field; 2]; Tau+1],\n    additive_noises: [[Field; 2]; Tau+1],\n    resulting_samples: pub [[Field; 9]; Tau+1],\n) -> pub Field {\n    dep::cheon_stehle::validate_keypair(\n        common_divisor,\n        scaling_factors,\n        additive_noises,\n        resulting_samples,\n    );\n    std::hash::pedersen_hash(common_divisor)\n}\n","path":"/root/aztec-grant-pss/circuits/keypair/src/main.nr"},"63":{"source":"use dep::bignum::{params::BigNumParams, RuntimeBigNum};\n\nfn encrypt_p<let Tau: u32, let Num: u32, let Bits: u32>(\n    params: BigNumParams<Num, Bits>,\n    key_set: [[Field; Num]; Tau],\n    entropy: [bool; Tau],\n    message: bool,\n) -> RuntimeBigNum<Num, Bits> {\n    encrypt_batched(params, key_set, entropy, message)\n}\n\n// Needs over 16 GiB of RAM to compile on Tau >= 1000 :(\nfn encrypt_expression<let Tau: u32, let Num: u32, let Bits: u32>(\n    params: BigNumParams<Num, Bits>,\n    key_set: [[Field; Num]; Tau],\n    entropy: [bool; Tau],\n    message: bool,\n) -> RuntimeBigNum<Num, Bits> {\n    let mut terms = [RuntimeBigNum::new(params); Tau + 1];\n    let mut sum = RuntimeBigNum::new(params);\n    for i in 0..Tau {\n        if entropy[i] {\n            let term = RuntimeBigNum::from_array(params, key_set[i]);\n            terms[i] = term;\n            sum = unsafe { sum.__add(term) };\n        }\n    }\n\n    let mut flags = [false; Tau + 1];\n    terms[Tau] = sum;\n    flags[Tau] = true;\n\n    RuntimeBigNum::evaluate_quadratic_expression(\n        params,\n        [[]; 0],\n        [[]; 0],\n        [[]; 0],\n        [[]; 0],\n        terms,\n        flags,\n    );\n    if message {\n        let _1 = RuntimeBigNum::one(params);\n        let _2 = _1 + _1;\n        sum += RuntimeBigNum::from_array(params, key_set[0]).udiv(_2);\n    }\n    sum\n}\n\n\n\nglobal batch_size: u32 = 8;\n\npub fn encrypt_batched<let Tau: u32, let Limbs: u32, let Bits: u32>(\n    params: BigNumParams<Limbs, Bits>,\n    key_set: [[Field; Limbs]; Tau],\n    entropy: [bool; Tau],\n    message: bool,\n) -> RuntimeBigNum<Limbs, Bits> {\n    let mut sum = RuntimeBigNum::new(params);\n    for batch_index in 0..(Tau / batch_size) {\n        let mut sub_entropy = [false; batch_size];\n        let mut sub_key_set = [[0; Limbs]; batch_size];\n        for term_index in 0..batch_size {\n            sub_entropy[term_index] = entropy[batch_index * batch_size + term_index];\n            sub_key_set[term_index] = key_set[batch_index * batch_size + term_index];\n        }\n        sum += select_key_samples(params, sub_key_set, sub_entropy);\n    }\n    {\n        let mut sub_entropy = [false; Tau % batch_size];\n        let mut sub_key_set = [[0; Limbs]; Tau % batch_size];\n        for term_index in 0..(Tau % batch_size) {\n            sub_entropy[term_index] = entropy[Tau - (Tau % batch_size) + term_index];\n            sub_key_set[term_index] = key_set[Tau - (Tau % batch_size) + term_index];\n        }\n        sum += select_key_samples(params, sub_key_set, sub_entropy);\n    }\n\n    if message {\n        let _1 = RuntimeBigNum::one(params);\n        let _2 = _1 + _1;\n        // TODO: fix yet another blocking maybe BigNum bug? \n        // sum += RuntimeBigNum::from_array(params, key_set[0]).udiv(_2);\n    }\n\n    sum\n}\n\nfn select_key_samples<let SubTau: u32, let Limbs: u32, let Bits: u32>(\n    params: BigNumParams<Limbs, Bits>,\n    sub_key_set: [[Field; Limbs]; SubTau],\n    sub_entropy: [bool; SubTau],\n) -> RuntimeBigNum<Limbs, Bits> {\n    let mut sum = RuntimeBigNum::new(params);\n    for index in 0..SubTau {\n        if sub_entropy[index] {\n            sum += RuntimeBigNum::from_array(params, sub_key_set[index]);\n        }\n    }\n    sum\n}\n\n\n\n\n\n\n/* Old implementations using BigNums fixed since compile time */\n// TODO: cleaning up and refactoring in progress\n\nglobal OLD_TAU: u32 = 1289;\n\nfn encrypt(key: [AGCD; OLD_TAU], entropy: [bool; OLD_TAU], message: bool) -> AGCD {\n    let _1: AGCD = BigNum::one();\n    let _2 = _1 + _1;\n\n    let mut sum = BigNum::new();\n    for index in 0..OLD_TAU {\n        if entropy[index] {\n            sum += key[index];\n        }\n    }\n    if message {\n        //sum += key[0].udiv(_2);\n    }\n    sum\n}\n\nfn encrypt_fast(mut key_set: [AGCD; OLD_TAU], entropy: [bool; OLD_TAU], message: bool) -> AGCD {\n    let mut terms = [BigNum::new(); OLD_TAU + 1];\n    let mut sum = BigNum::new();\n    for i in 0..OLD_TAU {\n        if entropy[i] {\n            terms[i] = key_set[i];\n            sum = unsafe { sum.__add(key_set[i]) };\n        }\n    }\n\n    let mut flags = [false; OLD_TAU + 1];\n    terms[OLD_TAU] = sum;\n    flags[OLD_TAU] = true;\n\n    BigNum::evaluate_quadratic_expression([[]; 0], [[]; 0], [[]; 0], [[]; 0], terms, flags);\n\n    if message {\n        let _1: AGCD = BigNum::one();\n        let _2 = _1 + _1;\n        //        sum += key_set[0].udiv(_2);\n    }\n    sum\n}\n\nglobal SLICE: u32 = 47;\n\nfn encrypt_maybe_faster(mut key: [AGCD; OLD_TAU], entropy: [bool; OLD_TAU], message: bool) -> AGCD {\n    let mut sums = [BigNum::new(); OLD_TAU / SLICE + 1];\n    for i in 0..(OLD_TAU / SLICE) {\n        let mut terms = [BigNum::new(); SLICE + 1];\n        for j in 0..SLICE {\n            if entropy[i * SLICE + j] {\n                terms[j + 1] = key[i * SLICE + j];\n                sums[i + 1] = unsafe { sums[i + 1].__add(key[i * SLICE + j]) };\n            }\n        }\n        sums[0] = unsafe { sums[0].__add(sums[i + 1]) };\n        terms[0] = sums[i + 1];\n        let mut flags = [false; SLICE + 1];\n        flags[0] = true;\n        BigNum::evaluate_quadratic_expression([[]; 0], [[]; 0], [[]; 0], [[]; 0], terms, flags);\n    }\n    let mut flags = [false; OLD_TAU / SLICE + 1];\n    flags[0] = true;\n    BigNum::evaluate_quadratic_expression([[]; 0], [[]; 0], [[]; 0], [[]; 0], sums, flags);\n\n    if message {\n        let _1: AGCD = BigNum::one();\n        let _2 = _1 + _1;\n        //        sums[0] += key[0].udiv(_2);\n    }\n\n    sums[0]\n}\n\nfn decrypt(p: AGCD, c: AGCD) -> bool {\n    let _1: AGCD = BigNum::one();\n    let _2 = _1 + _1;\n\n    // round_nearest(2*c/p)%2 == 1\n    let (c_udiv_p, c_umod_p) = c.udiv_mod(p);\n    (c_udiv_p + c_udiv_p + (c_umod_p + c_umod_p + p.udiv(_2)).udiv(p)).umod(_2) == _1\n}\n\nfn decrypt_noise(p: AGCD, c: AGCD) -> AGCD {\n    let _1: AGCD = BigNum::one();\n    let _2 = _1 + _1;\n\n    // ~ c%(p/2)\n    c.umod(p.udiv(_2))\n}\n\n#[test]\nfn test_encrypt_decrypt() {\n    let decryption_key = BigNum::from_slice([1, 4, 2, 8, 5, 7, 0, 0, 0]);\n    let encryption_key = [decryption_key; OLD_TAU];\n    let mut entropy = [false; OLD_TAU];\n    for i in 0..15 {\n        entropy[(i * 7) % OLD_TAU] = true;\n    }\n    assert(decrypt(decryption_key, encrypt_fast(encryption_key, entropy, true)) == true);\n    assert(decrypt(decryption_key, encrypt_fast(encryption_key, entropy, false)) == false);\n}\n\n// (Harcoded for security parameter=128)\npub fn validate_keypair<let Tau: u32>(\n    common_divisor_entropy: [Field; 8],\n    multiplier_entropy: [[Field; 2]; Tau+1],\n    additive_entropy: [[Field; 2]; Tau+1],\n    resulting_samples: [[Field; 9]; Tau+1],\n) {\n    // Assert that p has 128*7 bits or less\n    let TWO_POW_120 = 0x1_00000_00000_00000_00000_00000_00000;\n    for i in 0..7 {\n        assert(common_divisor_entropy[i].lt(TWO_POW_120));\n    }\n    let TWO_POW_56 = 0x10000_00000_00000;\n    assert(common_divisor_entropy[7].lt(TWO_POW_56));\n\n    let mut decryption_key_limbs = [0; 9];\n    for i in 0..8 {\n        decryption_key_limbs[i] = common_divisor_entropy[i];\n    }\n    let decryption_key: MC1031 = BigNum::from_slice(decryption_key_limbs);\n\n    for i in 0..Tau+1 {\n        // Assert that q's have 128+7 bits or less\n        assert(multiplier_entropy[i][0].lt(TWO_POW_120));\n        assert(multiplier_entropy[i][1].lt((2 << 15) as Field));\n\n        // Assert that r's have 128 bits or less\n        assert(additive_entropy[i][0].lt(TWO_POW_120));\n        assert(additive_entropy[i][1].lt((2 << 8) as Field));\n\n        let mut multiplier_limbs = [0; 9];\n        multiplier_limbs[0] = multiplier_entropy[i][0];\n        multiplier_limbs[1] = multiplier_entropy[i][1];\n        let multiplier = BigNum::from_slice(multiplier_limbs);\n\n        let mut added_noise_limbs = [0; 9];\n        added_noise_limbs[0] = additive_entropy[i][0];\n        added_noise_limbs[1] = additive_entropy[i][1];\n        let added_noise = BigNum::from_slice(added_noise_limbs);\n        let TWO_POW_127 = BigNum::from_slice([0, 0x80, 0, 0, 0, 0, 0, 0, 0]);\n\n        assert(\n            resulting_samples[i] == (decryption_key * multiplier + added_noise - TWO_POW_127).limbs,\n        );\n    }\n}\n\n#[test]\nfn bignum_bugs() {\n    let _1: AGCD = BigNum::one();\n    let _2 = _1 + _1;\n\n    _1.udiv_mod(_2);\n\n    let n: AGCD = BigNum::from_slice([0, 2, 0, 0, 0, 0, 0, 0, 0]);\n    let d: AGCD = BigNum::from_slice([1, 1, 0, 0, 0, 0, 0, 0, 0]);\n    n.udiv_mod(d);\n}\n\n#[test]\nfn uniform_noise_potential_detector() {\n    let _1: AGCD = BigNum::one();\n    let _2 = _1 + _1;\n\n    let dk = BigNum::from_slice([1, 4, 2, 8, 5, 7, 0, 0, 0]);\n    let ek = [dk + _1; OLD_TAU];\n    let mut entropy = [false; OLD_TAU];\n    for i in 0..15 {\n        entropy[(i * 7) % OLD_TAU] = true;\n    }\n    let real_noise = decrypt_noise(dk, encrypt(ek, entropy, true));\n    let fake_noise = decrypt_noise(dk, BigNum::from_slice([4, 4, 6, 2, 6, 7, 4, 2, 2]));\n    println(f\"real_noise: {real_noise}\");\n    println(f\"fake_noise: {fake_noise}\");\n}\n\n// Maximum Cyphertext considered (integers modulo 2^1031)\n\ntype MC1031 = BigNum<9, 1032, MC1031_Params>;\n\nstruct MC1031_Params {}\n\nimpl BigNumParamsGetter<9, 1032> for MC1031_Params {\n    fn get_params() -> BigNumParams<9, 1032> {\n        BigNumParams {\n            modulus: [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x800000000000000000],\n            double_modulus: [\n                0x01000000000000000000000000000000,\n                0xffffffffffffffffffffffffffffff,\n                0xffffffffffffffffffffffffffffff,\n                0xffffffffffffffffffffffffffffff,\n                0xffffffffffffffffffffffffffffff,\n                0xffffffffffffffffffffffffffffff,\n                0xffffffffffffffffffffffffffffff,\n                0xffffffffffffffffffffffffffffff,\n                0xffffffffffffffffff,\n            ],\n            modulus_u60: U60Repr {\n                limbs: [\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    0x00, 0x00, 0x00, 0x00, 0x0800,\n                ],\n            },\n            modulus_u60_x4: U60Repr {\n                limbs: [\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    0x00, 0x00, 0x00, 0x00, 0x0800, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                ],\n            },\n            redc_param: [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20000000000000000000],\n            has_multiplicative_inverse: false,\n        }\n    }\n}\n\nuse dep::bignum::BigNum;\nuse dep::bignum::params::BigNumParamsGetter;\nuse dep::bignum::utils::u60_representation::U60Repr;\n\n// Temporary encryption key moudulus hardcoded mock\n// TODO: no need for this anymore, got parametrized away\n// TODO: refactoring in progress\n\ntype AGCD = BigNum<9, 1031, AGCD_Params>;\n\nstruct AGCD_Params {}\n\nimpl BigNumParamsGetter<9, 1031> for AGCD_Params {\n    fn get_params() -> BigNumParams<9, 1031> {\n        BigNumParams {\n            modulus: [\n                0x8f7d4fcff973333634f8f8407c44fe,\n                0xd4b62d4ee67a7438e22655ce50e9d9,\n                0x39011824bf4cc94900ec9b93863df3,\n                0xee38e34c3f9d1480b450bcd998dc13,\n                0x77abc676fa9d0086cd0f914f0e4abb,\n                0x3011f4b5e1bf5cbb92c36c59facbd9,\n                0xaaf746a259bc2bf11795727e6e8bd1,\n                0x3fb152a206053f83d5814a4103936d,\n                0x7ae4e5b50cb9781d62,\n            ],\n            double_modulus: [\n                0x011efa9f9ff2e6666c69f1f080f889fc,\n                0x01a96c5a9dccf4e871c44cab9ca1d3b2,\n                0x01720230497e99929201d937270c7be6,\n                0x01dc71c6987f3a290168a179b331b825,\n                0x01ef578cedf53a010d9a1f229e1c9576,\n                0x016023e96bc37eb9772586d8b3f597b1,\n                0x0155ee8d44b37857e22f2ae4fcdd17a1,\n                0x017f62a5440c0a7f07ab0294820726da,\n                0xf5c9cb6a1972f03ac3,\n            ],\n            modulus_u60: U60Repr {\n                limbs: [\n                    0x0634f8f8407c44fe,\n                    0x08f7d4fcff973333,\n                    0x08e22655ce50e9d9,\n                    0x0d4b62d4ee67a743,\n                    0x0900ec9b93863df3,\n                    0x039011824bf4cc94,\n                    0xb450bcd998dc13,\n                    0x0ee38e34c3f9d148,\n                    0x06cd0f914f0e4abb,\n                    0x077abc676fa9d008,\n                    0x0b92c36c59facbd9,\n                    0x03011f4b5e1bf5cb,\n                    0x011795727e6e8bd1,\n                    0x0aaf746a259bc2bf,\n                    0x03d5814a4103936d,\n                    0x03fb152a206053f8,\n                    0x04e5b50cb9781d62,\n                    0x07ae,\n                ],\n            },\n            modulus_u60_x4: U60Repr {\n                limbs: [\n                    0x0634f8f8407c44fe,\n                    0x08f7d4fcff973333,\n                    0x08e22655ce50e9d9,\n                    0x0d4b62d4ee67a743,\n                    0x0900ec9b93863df3,\n                    0x039011824bf4cc94,\n                    0xb450bcd998dc13,\n                    0x0ee38e34c3f9d148,\n                    0x06cd0f914f0e4abb,\n                    0x077abc676fa9d008,\n                    0x0b92c36c59facbd9,\n                    0x03011f4b5e1bf5cb,\n                    0x011795727e6e8bd1,\n                    0x0aaf746a259bc2bf,\n                    0x03d5814a4103936d,\n                    0x03fb152a206053f8,\n                    0x04e5b50cb9781d62,\n                    0x07ae,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                ],\n            },\n            redc_param: [\n                0x8ac761800eec119fb49f0348f6fc3d,\n                0xf34e189546fcaa3e20a020c25a6e86,\n                0x65b821ffd2c3cbfd9732a0d16a1244,\n                0xd55569b0d17ad88fdec6dfb181d9a8,\n                0x4b761279d17923f2748a70dc3b3e42,\n                0xa6da6c493f7ddaf36216143da1dc17,\n                0x2555678a4e1602b0ccd60a8da8b969,\n                0x6183952f3d3e5aa1196d3842100ced,\n                0x0855168a51fc68190411,\n            ],\n            has_multiplicative_inverse: false,\n        }\n    }\n}\n","path":"/root/aztec-grant-pss/libs/cheon_stehle/src/lib.nr"},"64":{"source":"use crate::utils::map::map;\n\nuse crate::params::BigNumParamsGetter;\n\nuse crate::fns::{\n    constrained_ops::{\n        add, assert_is_not_equal, conditional_select, derive_from_seed, div, eq, mul, neg, sub,\n        udiv, udiv_mod, umod, validate_in_field, validate_in_range,\n    },\n    expressions::{__compute_quadratic_expression, evaluate_quadratic_expression},\n    serialization::{from_be_bytes, to_le_bytes},\n    unconstrained_ops::{\n        __add, __batch_invert, __batch_invert_slice, __derive_from_seed, __div, __eq, __invmod,\n        __is_zero, __mul, __neg, __pow, __sub, __tonelli_shanks_sqrt, __udiv_mod,\n    },\n};\nuse std::ops::{Add, Div, Mul, Neg, Sub};\n\npub struct BigNum<let N: u32, let MOD_BITS: u32, Params> {\n    pub limbs: [Field; N],\n}\n// We aim to avoid needing to add a generic parameter to this trait, for this reason we do not allow\n// accessing the limbs of the bignum except through slices.\npub trait BigNumTrait: Neg + Add + Sub + Mul + Div + Eq {\n    // TODO: this crashes the compiler? v0.32\n    // fn default() -> Self { std::default::Default::default  () }\n    pub fn new() -> Self;\n    pub fn one() -> Self;\n    pub fn derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self;\n    pub unconstrained fn __derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self;\n    pub fn from_slice(limbs: [Field]) -> Self;\n    pub fn from_be_bytes<let NBytes: u32>(x: [u8; NBytes]) -> Self;\n    pub fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes];\n\n    pub fn modulus() -> Self;\n    pub fn modulus_bits(self) -> u32;\n    pub fn num_limbs(self) -> u32;\n    pub fn get_limbs_slice(self) -> [Field];\n    pub fn get_limb(self, idx: u32) -> Field;\n    pub fn set_limb(&mut self, idx: u32, value: Field);\n\n    pub unconstrained fn __eq(self, other: Self) -> bool;\n    pub unconstrained fn __is_zero(self) -> bool;\n\n    pub unconstrained fn __neg(self) -> Self;\n    pub unconstrained fn __add(self, other: Self) -> Self;\n    pub unconstrained fn __sub(self, other: Self) -> Self;\n    pub unconstrained fn __mul(self, other: Self) -> Self;\n    pub unconstrained fn __div(self, other: Self) -> Self;\n    pub unconstrained fn __udiv_mod(self, divisor: Self) -> (Self, Self);\n    pub unconstrained fn __invmod(self) -> Self;\n    pub unconstrained fn __pow(self, exponent: Self) -> Self;\n\n    pub unconstrained fn __batch_invert<let M: u32>(to_invert: [Self; M]) -> [Self; M];\n    pub unconstrained fn __batch_invert_slice<let M: u32>(to_invert: [Self]) -> [Self];\n\n    pub unconstrained fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self>;\n\n    pub unconstrained fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        lhs: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        add: [Self; ADD_N],\n        add_flags: [bool; ADD_N],\n    ) -> (Self, Self);\n\n    pub fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        lhs: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        add: [Self; ADD_N],\n        add_flags: [bool; ADD_N],\n    );\n\n    pub fn eq(self, other: Self) -> bool {\n        self == other\n    }\n    pub fn assert_is_not_equal(self, other: Self);\n    pub fn validate_in_range(self);\n    pub fn validate_in_field(self);\n\n    pub fn udiv_mod(self, divisor: Self) -> (Self, Self);\n    pub fn udiv(self, divisor: Self) -> Self;\n    pub fn umod(self, divisor: Self) -> Self;\n\n    pub fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self;\n}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> Neg for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n    fn neg(self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs) }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> BigNumTrait for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n\n    fn new() -> Self {\n        Self { limbs: [0; N] }\n    }\n\n    fn one() -> Self {\n        let mut result = BigNum::new();\n        result.limbs[0] = 1;\n        result\n    }\n\n    fn derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self {\n        let params = Params::get_params();\n        Self { limbs: derive_from_seed::<_, MOD_BITS, _>(params, seed) }\n    }\n\n    unconstrained fn __derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self {\n        let params = Params::get_params();\n        Self { limbs: __derive_from_seed::<_, MOD_BITS, _>(params, seed) }\n    }\n\n    fn from_slice(limbs: [Field]) -> Self {\n        Self { limbs: limbs.as_array() }\n    }\n\n    fn from_be_bytes<let NBytes: u32>(x: [u8; NBytes]) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS, _>(x) }\n    }\n\n    fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes] {\n        to_le_bytes::<_, MOD_BITS, _>(self.limbs)\n    }\n\n    fn modulus() -> Self {\n        Self { limbs: Params::get_params().modulus }\n    }\n\n    fn modulus_bits(_: Self) -> u32 {\n        MOD_BITS\n    }\n\n    fn num_limbs(_: Self) -> u32 {\n        N\n    }\n\n    fn get_limbs_slice(self) -> [Field] {\n        self.limbs\n    }\n\n    fn get_limb(self, idx: u32) -> Field {\n        self.limbs[idx]\n    }\n\n    fn set_limb(&mut self, idx: u32, value: Field) {\n        self.limbs[idx] = value;\n    }\n\n    unconstrained fn __eq(self, other: Self) -> bool {\n        __eq(self.limbs, other.limbs)\n    }\n\n    unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    unconstrained fn __neg(self) -> Self {\n        let params = Params::get_params();\n        Self::from_slice(__neg(params, self.limbs))\n    }\n\n    unconstrained fn __add(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self::from_slice(__add(params, self.limbs, other.limbs))\n    }\n\n    unconstrained fn __sub(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self::from_slice(__sub(params, self.limbs, other.limbs))\n    }\n\n    unconstrained fn __mul(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self::from_slice(__mul::<_, MOD_BITS>(params, self.limbs, other.limbs))\n    }\n\n    unconstrained fn __div(self, divisor: Self) -> Self {\n        let params = Params::get_params();\n        Self::from_slice(__div::<_, MOD_BITS>(params, self.limbs, divisor.limbs))\n    }\n\n    unconstrained fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let (q, r) = __udiv_mod(self.limbs, divisor.limbs);\n        (Self { limbs: q }, Self { limbs: r })\n    }\n\n    unconstrained fn __invmod(self) -> Self {\n        let params = Params::get_params();\n        assert(params.has_multiplicative_inverse);\n        Self { limbs: __invmod::<_, MOD_BITS>(params, self.limbs) }\n    }\n\n    unconstrained fn __pow(self, exponent: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs) }\n    }\n\n    unconstrained fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M] {\n        let params = Params::get_params();\n        assert(params.has_multiplicative_inverse);\n        __batch_invert::<_, MOD_BITS, _>(params, x.map(|bn: Self| bn.limbs)).map(|limbs| {\n            Self { limbs }\n        })\n    }\n\n    unconstrained fn __batch_invert_slice<let M: u32>(x: [Self]) -> [Self] {\n        let params = Params::get_params();\n        assert(params.has_multiplicative_inverse);\n        __batch_invert_slice::<_, MOD_BITS>(params, x.map(|bn: Self| bn.limbs)).map(|limbs| {\n            Self { limbs }\n        })\n    }\n\n    unconstrained fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = Params::get_params();\n        let maybe_limbs = unsafe { __tonelli_shanks_sqrt(params, self.limbs) };\n        maybe_limbs.map(|limbs| Self { limbs })\n    }\n\n    unconstrained fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self) {\n        let params = Params::get_params();\n        let (q_limbs, r_limbs) = __compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn: Self| bn.limbs)),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn: Self| bn.limbs)),\n            rhs_flags,\n            map(linear_terms, |bn: Self| bn.limbs),\n            linear_flags,\n        );\n        (Self { limbs: q_limbs }, Self { limbs: r_limbs })\n    }\n\n    fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) {\n        let params = Params::get_params();\n        evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn: Self| bn.limbs)),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn: Self| bn.limbs)),\n            rhs_flags,\n            map(linear_terms, |bn: Self| bn.limbs),\n            linear_flags,\n        )\n    }\n\n    fn validate_in_field(self: Self) {\n        let params = Params::get_params();\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    fn validate_in_range(self) {\n        validate_in_range::<_, MOD_BITS>(self.limbs);\n    }\n\n    fn assert_is_not_equal(self, other: Self) {\n        let params = Params::get_params();\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = Params::get_params();\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q }, Self { limbs: r })\n    }\n\n    fn udiv(self, divisor: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs) }\n    }\n\n    fn umod(self, divisor: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs) }\n    }\n\n    fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self {\n        Self { limbs: conditional_select(lhs.limbs, rhs.limbs, predicate) }\n    }\n}\n\n// impl<let N: u32, Params> BigNumTrait<N, Params> for BigNum<N, Params> where Params: BigNumParamsGetter<N> {}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> std::ops::Add for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs) }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> std::ops::Sub for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs) }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> std::ops::Mul for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs) }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> std::ops::Div for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, other.limbs) }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> std::cmp::Eq for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n    fn eq(self, other: Self) -> bool {\n        let params = Params::get_params();\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n\n","path":"/root/nargo/github.com/fatlabsxyz/noir-bignum/main/src/bignum.nr"},"95":{"source":"use crate::params::BigNumParams as P;\n\nuse crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__div, __mul, __udiv_mod},\n};\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n */\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        std::hash::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[Field; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [Field; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n        let mut num_remaining_limbs =\n            (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n        let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n        let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n            + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n        for j in 0..num_limbs_in_bigfield {\n            let mut limb: Field = 0;\n            for _ in 0..15 {\n                let need_more_bytes = (byte_ptr < num_bytes);\n                let mut byte = hash_buffer[byte_ptr];\n                limb *= (256 * need_more_bytes as Field + (1 - need_more_bytes as Field));\n                limb += byte as Field * need_more_bytes as Field;\n                byte_ptr += need_more_bytes as u32;\n            }\n            bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n        }\n        bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n    }\n\n    let mut bigfield_rhs_limbs: [Field; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [Field; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n    result\n}\n\n/**\n* @brief conditional_select given the value of `predicate` return either `self` (if 0) or `other` (if 1)\n* @description should be cheaper than using an IF statement (TODO: check!)\n**/\npub(crate) fn conditional_select<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n    predicate: bool,\n) -> [Field; N] {\n    let mut result: [Field; N] = lhs;\n    for i in 0..N {\n        result[i] = (lhs[i] - rhs[i]) * predicate as Field + rhs[i];\n    }\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    let modulus = params.modulus;\n    for i in 0..N {\n        l *= two_pow_120;\n        r *= two_pow_120;\n        modulus_mod_n *= two_pow_120;\n        l += lhs[N - i - 1];\n        r += rhs[N - i - 1];\n        modulus_mod_n += modulus[N - i - 1];\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let mut diff = l - r;\n    let mut target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let mut is_equal_modulus: bool = true;\n    let mut is_equal_zero: bool = true;\n    for i in 0..N {\n        is_equal_modulus = is_equal_modulus & (diff[i] == params.modulus[i]);\n        is_equal_zero = is_equal_zero & (diff[i] == 0);\n    }\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [Field; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = modulus[i] - val[i];\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    p_minus_self[0] += borrow_flags[0] as Field * two_pow_120;\n    for i in 1..N - 1 {\n        p_minus_self[i] += (borrow_flags[i] as Field * two_pow_120 - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= borrow_flags[N - 2] as Field;\n    let mut compare = val;\n    compare = p_minus_self;\n    validate_in_range::<_, MOD_BITS>(compare);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N - 1) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [Field; N], rhs: [Field; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (result, carry_flags, borrow_flags) = unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, MOD_BITS>(result);\n\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let carry_shift = 0x1000000000000000000000000000000;\n\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] - rhs[0] + addend[0] - result[0] - 1\n        + (borrow_flags[0] as Field * borrow_shift)\n        - (carry_flags[0] as Field * carry_shift);\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - borrow_flags[i - 1] as Field\n            + carry_flags[i - 1] as Field\n            + ((borrow_flags[i] as Field - carry_flags[i] as Field) * borrow_shift);\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] - rhs[N - 1] + addend[N - 1]\n        - result[N - 1]\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    let (result, borrow_flags) = unsafe { __neg_with_flags(params, val) };\n    validate_in_range::<_, MOD_BITS>(result);\n    let modulus = params.modulus;\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let result_limb = modulus[0] - val[0] - result[0] + (borrow_flags[0] as Field * borrow_shift);\n    assert(result_limb == 0);\n    for i in 1..N - 1 {\n        let result_limb = modulus[i] - val[i] - result[i] - borrow_flags[i - 1] as Field\n            + (borrow_flags[i] as Field * borrow_shift);\n        assert(result_limb == 0);\n    }\n    let result_limb = modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as Field;\n    assert(result_limb == 0);\n    result\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    let (result, carry_flags, borrow_flags, overflow_modulus) =\n        unsafe { __add_with_flags(params, lhs, rhs) };\n    validate_in_range::<_, MOD_BITS>(result);\n    let modulus = params.modulus;\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let carry_shift = 0x1000000000000000000000000000000;\n\n    let mut subtrahend: [Field; N] = [0; N];\n    if (overflow_modulus) {\n        subtrahend = modulus;\n    }\n    let result_limb = lhs[0] + rhs[0] - subtrahend[0] - result[0]\n        + (borrow_flags[0] as Field * borrow_shift)\n        - (carry_flags[0] as Field * carry_shift);\n    assert(result_limb == 0);\n    for i in 1..N - 1 {\n        let result_limb = lhs[i] + rhs[i] - subtrahend[i] - result[i] - borrow_flags[i - 1] as Field\n            + carry_flags[i - 1] as Field\n            + ((borrow_flags[i] as Field - carry_flags[i] as Field) * borrow_shift);\n        assert(result_limb == 0);\n    }\n    let result_limb = lhs[N - 1] + rhs[N - 1]\n        - subtrahend[N - 1]\n        - result[N - 1]\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n    result\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (result, carry_flags, borrow_flags, underflow) =\n        unsafe { __sub_with_flags(params, lhs, rhs) };\n    validate_in_range::<_, MOD_BITS>(result);\n    let modulus = params.modulus;\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let carry_shift = 0x1000000000000000000000000000000;\n\n    let mut addend: [Field; N] = [0; N];\n    if (underflow) {\n        addend = modulus;\n    }\n    let result_limb = lhs[0] - rhs[0] + addend[0] - result[0]\n        + (borrow_flags[0] as Field * borrow_shift)\n        - (carry_flags[0] as Field * carry_shift);\n    assert(result_limb == 0);\n    for i in 1..N - 1 {\n        let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - borrow_flags[i - 1] as Field\n            + carry_flags[i - 1] as Field\n            + ((borrow_flags[i] as Field - carry_flags[i] as Field) * borrow_shift);\n        assert(result_limb == 0);\n    }\n    let result_limb = lhs[N - 1] - rhs[N - 1] + addend[N - 1]\n        - result[N - 1]\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n    result\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    evaluate_quadratic_expression(\n        params,\n        [[lhs]],\n        [[false]],\n        [[rhs]],\n        [[false]],\n        [result],\n        [true],\n    );\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    evaluate_quadratic_expression(\n        params,\n        [[result]],\n        [[false]],\n        [[rhs]],\n        [[false]],\n        [lhs],\n        [true],\n    );\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n\n    // self / divisor = quotient rounded\n    // quotient * divisor + remainder - self = 0\n    evaluate_quadratic_expression(\n        params,\n        [[quotient]],\n        [[false]],\n        [[divisor]],\n        [[false]],\n        [numerator, remainder],\n        [true, false],\n    );\n    // we need (remainder < divisor)\n    // implies (divisor - remainder > 0)\n    validate_gt::<_, MOD_BITS>(divisor, remainder);\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor \n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n\n","path":"/root/nargo/github.com/fatlabsxyz/noir-bignum/main/src/fns/constrained_ops.nr"},"96":{"source":"use crate::utils::split_bits;\n\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n * In this file:\n *\n * __compute_quadratic_expression_with_borrow_flags\n * __add_linear_expression\n * __compute_quadratic_expression_product\n * __compute_quadratic_expression\n * evaluate_quadratic_expression\n */\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\nunconstrained fn __compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N], [Field; 2 * N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let modulus: [Field; N] = params.modulus;\n    let modulus_bits = MOD_BITS;\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        modulus_bits,\n        modulus,\n        params.modulus_u60_x4,\n    );\n    assert(remainder == [0; N]);\n\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] * modulus[j];\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N] = [0; 2 * N];\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    let downshift: Field = 1 / two_pow_120;\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits = (mulout_p[0] - mulout_n[0] + (borrow_flags[0] * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n    flags: [bool; M],\n) -> ([Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [Field; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [Field; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + modulus2[j] - x[i][j];\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn __compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut add: [Field; N] = [0; N];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [Field; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] * rhs[k][j]);\n            }\n        }\n        mulout[i] += add[i];\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        k,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([Field; N], [Field; N], [Field; 2 * N]) = unsafe {\n        __compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [Field; N] = params.double_modulus;\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i];\n                    t0[k][i] += double_modulus[i];\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i];\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i];\n                    t1[k][i] += double_modulus[i];\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i];\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i];\n                t4[i] += double_modulus[i];\n            } else {\n                t4[i] += linear_terms[j][i];\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term = t0[k][i] * t1[k][j] - quotient[i] * params.modulus[j];\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j];\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] * params.modulus[j];\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n","path":"/root/nargo/github.com/fatlabsxyz/noir-bignum/main/src/fns/expressions.nr"},"99":{"source":"use crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\nuse crate::fns::unconstrained_ops::{__add, __eq, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\n\nglobal TWO_POW_60: u64 = 0x1000000000000000;\n\n/**\n * In this file:\n *\n * __validate_in_field_compute_borrow_flags\n * __validate_gt_remainder\n * __neg_with_flags\n * __add_with_flags\n * __sub_with_flags\n * __barrett_reduction\n * __tonelli_shanks_sqrt\n */\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [Field; N] = params.modulus;\n    flags[0] = modulus[0].lt(val[0]);\n    for i in 1..N - 1 {\n        flags[i] = modulus[i].lt(val[i] + flags[i - 1] as Field);\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N]) {\n    let a_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let mut b_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let underflow = b_u60.gte(a_u60);\n    assert(underflow == false, \"BigNum::validate_gt check fails\");\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 1;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            if (carry & borrow == 1) {\n                carry = 0;\n                borrow = 0;\n            }\n            carry_flags[i / 2] = carry as bool;\n            borrow_flags[i / 2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> ([Field; N], [bool; N]) {\n    let x_u60: U60Repr<N, 2> = U60Repr::from(val);\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut borrow_in: u64 = 0;\n\n    let mut borrow_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let sub_term = x_u60.limbs[i] + borrow_in;\n        let borrow = (sub_term > params.modulus_u60.limbs[i]) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + params.modulus_u60.limbs[i] - sub_term;\n\n        borrow_in = borrow;\n        if ((i & 1) == 1) {\n            borrow_flags[i / 2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let b_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n    let add_u60 = a_u60 + b_u60;\n\n    let overflow = add_u60.gte(params.modulus_u60);\n\n    let mut subtrahend_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    if overflow {\n        subtrahend_u60 = params.modulus_u60;\n    }\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + b_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = subtrahend_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            let idx = (i - 1) / 2;\n            if (carry & borrow == 1) {\n                carry = 0;\n                borrow = 0;\n            }\n            carry_flags[idx] = carry as bool;\n            borrow_flags[idx] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let b_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let underflow = b_u60.gte(a_u60 + U60Repr::one());\n\n    let addend_u60: U60Repr<N, 2> = if underflow {\n        params.modulus_u60\n    } else {\n        U60Repr { limbs: [0; 2 * N] }\n    };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + addend_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            if (carry & borrow == 1) {\n                carry = 0;\n                borrow = 0;\n            }\n            carry_flags[i / 2] = carry as bool;\n            borrow_flags[i / 2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [Field; 2 * N],\n    redc_param: [Field; N],\n    k: u32,\n    modulus: [Field; N],\n    modulus_u60: U60Repr<N, 4>,\n) -> ([Field; N], [Field; N]) {\n    // for each i in 0..(N + N), adds x[i] * redc_param[j] to mulout[i + j] for each j in 0..N\n    let mut mulout: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout[i + j] += x[i] * redc_param[j];\n        }\n    }\n\n    mulout = split_bits::__normalize_limbs(mulout, 3 * N - 1);\n    let mulout_u60: U60Repr<N, 6> = U60Repr::new(mulout);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient_u60 = mulout_u60.shr((k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = quotient_u60.into_field_array();\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] += partial_quotient_full[i] * modulus[j];\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    for i in 0..(N + N) {\n        let (lo, hi) = split_bits::split_120_bits(quotient_mul_modulus_normalized[i]);\n        quotient_mul_modulus_normalized[i] = lo;\n\n        // Propagate higher bits to the next index\n        // TODO: what is faster, leaving this if statement in or out?\n        // (array is size-1 too large so we can tolerate adding 0 into max element)\n        if (i + 1 < N + N) {\n            quotient_mul_modulus_normalized[i + 1] += hi;\n        }\n    }\n\n    let quotient_mul_modulus_u60: U60Repr<N, 4> = U60Repr::new(quotient_mul_modulus_normalized);\n    // convert the input into U60Repr\n    let x_u60: U60Repr<N, 4> = U60Repr::new(x);\n    let mut remainder_u60 = x_u60 - quotient_mul_modulus_u60;\n    // barrett reduction is quircky so might need to remove a few modulus_u60 from the remainder\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    } else {}\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n\n    let q: [Field; N] = U60Repr::into(quotient_u60);\n    let r: [Field; N] = U60Repr::into(remainder_u60);\n\n    (q, r)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut target: U60Repr<N, 2> = params.modulus_u60 - U60Repr::one();\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target.limbs[0] & 1) == 1;\n        if (lsb_is_one) {\n            break;\n        }\n        result += 1;\n        target.shr1();\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [Field; N],\n    p_minus_one_over_two: [Field; N],\n) -> (bool, [Field; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [Field; N] = __one();\n    let neg_one = __neg(params, one);\n    let found = __eq(exped, neg_one);\n    let mut result: (bool, [Field; N]) = (found, target);\n    if (!found) {\n        let _target = __add(params, target, one);\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [Field; N] {\n    let mut target: [Field; N] = __one();\n    let p_minus_one_over_two: U60Repr<N, 2> = (params.modulus_u60 - U60Repr::one()).shr(1);\n    let p_minus_one_over_two: [Field; N] = U60Repr::into(p_minus_one_over_two);\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [Field; N],\n    i: u32,\n) -> u32 {\n    let one: [Field; N] = __one();\n    let is_one = __eq(t2m, one);\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n","path":"/root/nargo/github.com/fatlabsxyz/noir-bignum/main/src/fns/unconstrained_helpers.nr"},"100":{"source":"use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __multiplicative_generator, __primitive_root_log_size,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\n/**\n * In this file:\n *\n * __one\n * __derive_from_seed\n * __eq\n * __is_zero\n * __neg\n * __add\n * __sub\n * __mul_with_quotient\n * __mul\n * __div\n * __udiv_mod\n * __invmod\n * __pow\n * __batch_invert\n * __batch_invert_slice\n */\n\npub(crate) unconstrained fn __one<let N: u32>() -> [Field; N] {\n    let mut limbs: [Field; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [Field; N], rhs: [Field; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [Field; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    limbs: [Field; N],\n) -> [Field; N] {\n    let f: [Field; N] = limbs;\n    let x_u60: U60Repr<N, 2> = U60Repr::from(f);\n    U60Repr::into(params.modulus_u60 - x_u60)\n}\n\npub(crate) unconstrained fn __add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let x_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let y_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let mut z_u60 = x_u60 + y_u60;\n\n    if z_u60.gte(params.modulus_u60) {\n        z_u60 = z_u60 - params.modulus_u60;\n    }\n    U60Repr::into(z_u60)\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    __add(params, lhs, __neg(params, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += lhs[i] * rhs[j];\n        }\n    }\n    let to_reduce = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(\n        to_reduce,\n        params.redc_param,\n        MOD_BITS,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    let inv_divisor = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut quotient_u60: U60Repr<N, 2> = U60Repr::from([0; N]);\n    let mut remainder_u60: U60Repr<N, 2> = U60Repr::from(numerator);\n\n    let mut divisor_u60: U60Repr<N, 2> = U60Repr::from(divisor);\n    let b = divisor_u60;\n\n    let numerator_msb = remainder_u60.get_msb();\n    let divisor_msb = divisor_u60.get_msb();\n    if divisor_msb > numerator_msb {\n        ([0; N], numerator)\n    } else {\n        let mut bit_difference = numerator_msb - divisor_msb;\n\n        let mut accumulator_u60: U60Repr<N, 2> = U60Repr::one();\n        divisor_u60 = divisor_u60.shl(bit_difference);\n        accumulator_u60 = accumulator_u60.shl(bit_difference);\n\n        if (divisor_u60.gte(remainder_u60 + U60Repr::one())) {\n            divisor_u60.shr1();\n            accumulator_u60.shr1();\n        }\n        for _ in 0..(N * 120) {\n            if (remainder_u60.gte(b) == false) {\n                break;\n            }\n\n            // we've shunted 'divisor' up to have the same bit length as our remainder.\n            // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n            if (remainder_u60.gte(divisor_u60)) {\n                remainder_u60 -= divisor_u60;\n                // we can use OR here instead of +, as\n                // accumulator is always a nice power of two\n                quotient_u60 = quotient_u60 + accumulator_u60;\n            }\n            divisor_u60.shr1(); // >>= 1;\n            accumulator_u60.shr1(); //  >>= 1;\n        }\n\n        (U60Repr::into(quotient_u60), U60Repr::into(remainder_u60))\n    }\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    let one_u60: U60Repr<N, 2> = U60Repr::one();\n    let exp_u60 = params.modulus_u60 - (one_u60 + one_u60);\n    let exp = U60Repr::into(exp_u60);\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n    exponent: [Field; N],\n) -> [Field; N] {\n    let x: U60Repr<N, 2> = U60Repr::from(exponent);\n\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [Field; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if x.get_bit(num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n) -> [[Field; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut result: [[Field; N]; M] = [[0; N]; M];\n    let mut temporaries: [[Field; N]; N] = std::mem::zeroed();\n    for i in 0..N {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    let mut T0: [Field; N] = [0; N];\n    for i in 0..N {\n        let idx = N - 1 - i;\n        if (!__is_zero(x[idx])) {\n            T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]],\n) -> [[Field; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut result: [[Field; N]] = [[0; N]];\n    let mut temporaries: [[Field; N]; N] = std::mem::zeroed();\n    for i in 0..N {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n        result = result.push_back([0; N]);\n    }\n\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    let mut T0: [Field; N] = [0; N];\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (__is_zero(x[idx]) == false) {\n            T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [Field; N],\n) -> std::option::Option<[Field; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one_u60: U60Repr<N, 2> = U60Repr::one();\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let mut Q = (params.modulus_u60 - one_u60).shr(primitive_root_log_size - 1);\n    let Q_minus_one_over_two_u60 = (Q - one_u60).shr(2);\n    let Q_minus_one_over_two: [Field; N] = U60Repr::into(Q_minus_one_over_two_u60);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [Field; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut result = Option::none();\n    let one: [Field; N] = __one::<N>();\n    if (__eq(check, one)) {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n","path":"/root/nargo/github.com/fatlabsxyz/noir-bignum/main/src/fns/unconstrained_ops.nr"},"110":{"source":"global TWO_POW_56: u64 = 0x100000000000000;\nglobal TWO_POW_60: u64 = 0x1000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 120 bit fields\npub unconstrained fn split_120_bits(mut x: Field) -> (Field, Field) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_56 = ((x as u64) % TWO_POW_56) as Field;\n\n    let low = low_lower_64 + TWO_POW_64 * low_upper_56;\n    let high = (x - low_upper_56) / TWO_POW_56 as Field;\n\n    (low, high)\n}\n\n/**\n * @brief Decomposes a single field into two 60 bit fields\n *\n * @description Expects the input limb to be in the range [0, ..., 2^{120 - 1}]\n **/\npub unconstrained fn split_60_bits(x: Field) -> (u64, u64) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let x_lower_64 = (x as u64);\n    let low = x_lower_64 % TWO_POW_60;\n    let high = ((x - (low as Field)) / TWO_POW_60 as Field) as u64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [Field; N] {\n    let mut normalized: [Field; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(next);\n\n        normalized[i] = lo;\n        next = input[i + 1] + hi;\n    }\n    {\n        let (lo, hi) = split_120_bits(next);\n        normalized[range - 1] = lo;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/root/nargo/github.com/fatlabsxyz/noir-bignum/main/src/utils/split_bits.nr"},"111":{"source":"use crate::utils::msb::get_msb64;\nuse crate::utils::split_bits;\n\n/**\n * @brief U60Repr represents a BigNum element as a sequence of 60-bit unsigned integers.\n *\n * @description: used in unconstrained functions when computing witness values.\n * It is helpful to use u60 types when evaluating addition operations that can overflow the field modulus,\n * as well as when performing bit shifts.\n */\npub struct U60Repr<let N: u32, let NumSegments: u32> {\n    pub(crate) limbs: [u64; N * NumSegments],\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Add for U60Repr<N, NumSegments> {\n    fn add(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut carry: u64 = 0;\n        for i in 0..N * NumSegments {\n            let mut add: u64 = self.limbs[i] + b.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            result.limbs[i] = add;\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Sub for U60Repr<N, NumSegments> {\n    fn sub(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut borrow: u64 = 0;\n        let mut borrow_in: u64 = 0;\n\n        for i in 0..N * NumSegments {\n            borrow = ((b.limbs[i] + borrow_in) > self.limbs[i]) as u64;\n            let sub = (borrow << 60) + self.limbs[i] - b.limbs[i] - borrow_in;\n            result.limbs[i] = sub;\n            borrow_in = borrow;\n        }\n\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::convert::From<[Field; N]> for U60Repr<N, NumSegments> {\n    fn from(input: [Field; N]) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..(N) {\n            let (lo, hi) = unsafe { split_bits::split_60_bits(input[i]) };\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::convert::Into<[Field; N]> for U60Repr<N, NumSegments> {\n    fn into(x: U60Repr<N, NumSegments>) -> [Field; N] {\n        let mut result: [Field; N] = [0; N];\n        let two_pow_60: Field = 0x1000000000000000;\n        for i in 0..N {\n            result[i] = x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * two_pow_60);\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::cmp::Eq for U60Repr<N, NumSegments> {\n    fn eq(self, other: Self) -> bool {\n        self.limbs == other.limbs\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> U60Repr<N, NumSegments> {\n\n    pub(crate) unconstrained fn new<let NumFieldSegments: u32>(\n        x: [Field; N * NumFieldSegments],\n    ) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..(N * NumFieldSegments) {\n            let (lo, hi) = split_bits::split_60_bits(x[i]);\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn one() -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub(crate) unconstrained fn into_field_array(\n        x: U60Repr<N, NumSegments>,\n    ) -> [Field; N * NumSegments / 2] {\n        let mut result: [Field; N * NumSegments / 2] = [0; N * NumSegments / 2];\n        let two_pow_60: Field = 0x1000000000000000;\n        for i in 0..(N * NumSegments / 2) {\n            result[i] = x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * two_pow_60);\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn gte(self, b: Self) -> bool {\n        let mut result = false;\n        let mut early_exit = false;\n        for i in 0..(N * NumSegments) {\n            if (b.limbs[(N * NumSegments) - 1 - i] < self.limbs[((N * NumSegments) - 1 - i)]) {\n                result = true;\n                early_exit = true;\n                break;\n            } else if (\n                b.limbs[(N * NumSegments) - 1 - i] != self.limbs[((N * NumSegments) - 1 - i)]\n            ) {\n                result = false;\n                early_exit = true;\n                break;\n            }\n        }\n        if (early_exit == false) {\n            result = (self.limbs[0] == b.limbs[0]);\n        }\n        result\n    }\n\n    pub(crate) fn get_bit(self, bit: u32) -> bool {\n        let segment_index = bit / 60;\n        let uint_index = bit % 60;\n\n        let limb: u64 = self.limbs[segment_index];\n        let value = (limb >> uint_index as u8) & 1;\n        value == 1\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = shift % 60;\n        let remainder_shift = 60 - limb_shift;\n        let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n        result.limbs[0] = (self.limbs[0 + num_shifted_limbs] >> limb_shift as u8);\n\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i + num_shifted_limbs];\n            result.limbs[i] = (value >> limb_shift as u8);\n            let remainder: u64 = (value << remainder_shift as u8) & mask;\n            result.limbs[i - 1] = result.limbs[i - 1] + remainder;\n        }\n        result\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr1(&mut self) {\n        let value = self.limbs[NumSegments * N - 1];\n        self.limbs[NumSegments * N - 1] = value >> 1;\n\n        let mut remainder = (value & 1) << 59;\n\n        for i in 0..N * NumSegments {\n            let value = self.limbs[N * NumSegments - 1 - i];\n            self.limbs[N * NumSegments - 1 - i] = (value >> 1) + remainder;\n            remainder = (value << 59) & 0x800000000000000;\n        }\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shl(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; NumSegments * N] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = (shift % 60) as u8;\n        let remainder_shift: u8 = 60 - limb_shift as u8;\n\n        // 83\n        // limb shift = 1\n        // inside shift = 19 bits to the left\n        // meaning we have 19 carry bits and 41 remainder bits\n        let mask: u64 = (1 as u64 << 60) - 1;\n        //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n        let value = self.limbs[0];\n\n        let mut remainder = (value >> remainder_shift);\n        result.limbs[num_shifted_limbs] = (value << (limb_shift as u8)) & mask;\n\n        // shift 84. num shifted = 1\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i];\n            let upshift = ((value << (limb_shift as u8)) + remainder) & mask;\n            result.limbs[i + num_shifted_limbs] = upshift;\n            remainder = (value >> remainder_shift);\n            // let remainder: u64 = (self.limbs.get(i + num_shifted_limbs as u64) << remainder_shift as u8) & mask;\n            // result.limbs.set(i - 1, result.limbs.get(i - 1) + remainder);\n        }\n        result\n    }\n\n    pub(crate) fn increment(&mut self) {\n        let mut carry: u64 = 0;\n\n        let mut add: u64 = self.limbs[0] + 1;\n        carry = add >> 60;\n        add = add - (carry << 60);\n        self.limbs[0] = add;\n\n        for i in 1..NumSegments * N {\n            let mut add: u64 = self.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            self.limbs[i] = add;\n        }\n    }\n\n    pub(crate) unconstrained fn get_msb(val: Self) -> u32 {\n        let mut count = 0;\n        for i in 0..N * NumSegments {\n            let v = val.limbs[((N * NumSegments) - 1 - i)];\n            if (v > 0) {\n                count = 60 * ((N * NumSegments) - 1 - i) + get_msb64(v);\n                break;\n            }\n        }\n        count\n    }\n}\n","path":"/root/nargo/github.com/fatlabsxyz/noir-bignum/main/src/utils/u60_representation.nr"}},"names":["main"],"brillig_names":["field_less_than","decompose_hint","lte_hint","__mul","__compute_quadratic_expression_with_borrow_flags","__add_with_flags","__sub_with_flags","directive_invert"]}