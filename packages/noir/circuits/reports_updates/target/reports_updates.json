{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":8308125259965203988,"abi":{"parameters":[{"name":"board_used","type":{"kind":"array","length":16,"type":{"kind":"field"}},"visibility":"private"},{"name":"old_board_salt","type":{"kind":"field"},"visibility":"private"},{"name":"new_board_salt","type":{"kind":"field"},"visibility":"private"},{"name":"reason","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"target","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"trap","type":{"kind":"boolean"},"visibility":"private"},{"name":"action_salt","type":{"kind":"field"},"visibility":"private"},{"name":"params","type":{"kind":"struct","path":"bignum::params::BigNumParams","fields":[{"name":"has_multiplicative_inverse","type":{"kind":"boolean"}},{"name":"modulus","type":{"kind":"array","length":9,"type":{"kind":"field"}}},{"name":"modulus_u60","type":{"kind":"struct","path":"bignum::utils::u60_representation::U60Repr","fields":[{"name":"limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":64}}}]}},{"name":"modulus_u60_x4","type":{"kind":"struct","path":"bignum::utils::u60_representation::U60Repr","fields":[{"name":"limbs","type":{"kind":"array","length":36,"type":{"kind":"integer","sign":"unsigned","width":64}}}]}},{"name":"double_modulus","type":{"kind":"array","length":9,"type":{"kind":"field"}}},{"name":"redc_param","type":{"kind":"array","length":9,"type":{"kind":"field"}}}]},"visibility":"public"},{"name":"decryption_key","type":{"kind":"array","length":9,"type":{"kind":"field"}},"visibility":"private"},{"name":"hit_reports","type":{"kind":"array","length":3,"type":{"kind":"array","length":9,"type":{"kind":"field"}}},"visibility":"public"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"field"},{"kind":"field"},{"kind":"field"},{"kind":"boolean"},{"kind":"field"}]},"visibility":"public"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13265554733035650515":{"error_kind":"string","string":"BigNum::validate_gt check fails"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"3":{"source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n}\n","path":"std/array/mod.nr"},"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"12":{"source":"// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n","path":"std/convert.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"20":{"source":"pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"29":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n}\n","path":"std/lib.nr"},"61":{"source":"use bignum::params::BigNumParams;\nuse bignum::RuntimeBigNum::from_array;\nuse cheon_stehle::decrypt;\nuse std::hash::pedersen_hash as hash;\n\nglobal Players: u32 = 4;\nglobal Size: u32 = 16;\nglobal Limbs: u32 = 9;\nglobal Bits: u32 = 1031;\n\nfn tile_has_trap(tile: Field) -> bool {\n    tile == 0\n}\nfn tile_has_agent(tile: Field) -> bool {\n    (tile != 0) & (tile != 1)\n}\n\n\n#[oracle(oracle_board)]\nunconstrained fn oracle_board(board: [Field; Size]) -> () {}\nunconstrained fn output_board(board: [Field; Size]) -> () {\n    oracle_board(board);\n}\n#[oracle(oracle_detect)]\nunconstrained fn oracle_detect(detect: u32) -> () {}\nunconstrained fn output_detect(detect: u32) -> () {\n    oracle_detect(detect);\n}\n\nfn main(\n    mut board_used: [Field; Size],\n    old_board_salt: Field,\n    new_board_salt: Field,\n    reason: u32,\n    target: u32,\n    trap: bool,\n    action_salt: Field,\n    params: pub BigNumParams<Limbs, Bits>,\n    decryption_key: [Field; Limbs],\n    hit_reports: pub [[Field; Limbs]; Players - 1],\n) -> pub (Field, Field, Field, bool, Field) {\n    let old_board_digest = hash([old_board_salt, hash(board_used)]);\n    let action_digest = hash(\n        [action_salt, reason as Field, target as Field, trap as Field],\n    );\n\n    let decryption_key_digest = hash(decryption_key);\n    let dk = from_array(params, decryption_key);\n    let detect = hit_reports.any(|encrypted_report| {\n        decrypt(dk, from_array(params, encrypted_report))\n    })\n        | (trap & tile_has_agent(board_used[target]))\n        | tile_has_trap(board_used[target]);\n\n    if trap {\n        board_used[target] = 0; // Trap\n    } else {\n        board_used[reason] -= 1; // Decrement agents\n        board_used[target] += 1; // Increment agents\n    }\n    if detect {\n        board_used[target] = 1; // Void tile\n        let _ = unsafe { output_detect(target) };\n    }\n\n    let _ = unsafe { output_board(board_used) };\n    let new_board_digest = hash([new_board_salt, hash(board_used)]);\n    let ded = board_used.all(|v| (v == 0) | (v == 1));\n\n    (old_board_digest, new_board_digest, action_digest, ded, decryption_key_digest)\n}\n","path":"/root/box/terry-escape/packages/noir/circuits/reports_updates/src/main.nr"},"95":{"source":"use crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__add, __div, __mul, __neg, __sub, __udiv_mod},\n};\nuse crate::params::BigNumParams as P;\n\nglobal TWO_POW_120: Field = 0x1000000000000000000000000000000;\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n */\n\npub(crate) fn limbs_to_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    limbs: [Field; N],\n) -> Field {\n    let TWO_POW_120 = 0x1000000000000000000000000000000;\n    if N > 2 {\n        // validate that the limbs is less than the modulus the grumpkin modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, MOD_BITS>(grumpkin_modulus, limbs);\n        // validate that the limbs are in range\n        validate_in_range::<N, MOD_BITS>(limbs);\n    }\n    // validate the limbs sum up to the field value\n    if N < 2 {\n        limbs[0]\n    } else if N == 2 {\n        validate_in_range::<N, MOD_BITS>(limbs);\n        limbs[0] + limbs[1] * TWO_POW_120\n    } else {\n        // validate_in_range::<N, 254>(limbs);\n        limbs[0] + limbs[1] * TWO_POW_120 + limbs[2] * TWO_POW_120 * TWO_POW_120\n    }\n}\n\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    field: Field,\n) -> [Field; N] {\n    // Safety: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result = unsafe { __from_field::<N>(field) };\n\n    if !std::runtime::is_unconstrained() {\n        // validate the limbs are in range and the value in total is less than 2^254\n\n        let TWO_POW_120 = 0x1000000000000000000000000000000;\n        // validate that the last limb is less than the modulus\n        if N > 2 {\n            // validate that the result is less than the modulus\n            let mut grumpkin_modulus = [0; N];\n            grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n            grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n            grumpkin_modulus[2] = 0x3064;\n            validate_gt::<N, MOD_BITS>(grumpkin_modulus, result);\n            // validate that the limbs are in range\n            validate_in_range::<N, MOD_BITS>(result);\n        }\n        // validate the limbs sum up to the field value\n        let field_val = if N < 2 {\n            result[0]\n        } else if N == 2 {\n            validate_in_range::<N, MOD_BITS>(result);\n            result[0] + result[1] * TWO_POW_120\n        } else {\n            validate_in_range::<N, MOD_BITS>(result);\n            result[0] + result[1] * TWO_POW_120 + result[2] * TWO_POW_120 * TWO_POW_120\n        };\n        assert(field_val == field);\n    }\n\n    result\n}\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        std::hash::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[Field; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [Field; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n        let mut num_remaining_limbs =\n            (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n        let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n        let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n            + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n        for j in 0..num_limbs_in_bigfield {\n            let mut limb: Field = 0;\n            for _ in 0..15 {\n                let need_more_bytes = (byte_ptr < num_bytes);\n                let mut byte = hash_buffer[byte_ptr];\n                limb *= (256 * need_more_bytes as Field + (1 - need_more_bytes as Field));\n                limb += byte as Field * need_more_bytes as Field;\n                byte_ptr += need_more_bytes as u32;\n            }\n            bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n        }\n        bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n    }\n\n    let mut bigfield_rhs_limbs: [Field; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [Field; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n    result\n}\n\n/**\n* @brief conditional_select given the value of `predicate` return either `self` (if 0) or `other` (if 1)\n* @description should be cheaper than using an IF statement (TODO: check!)\n**/\npub(crate) fn conditional_select<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n    predicate: bool,\n) -> [Field; N] {\n    let mut result: [Field; N] = lhs;\n    for i in 0..N {\n        result[i] = (lhs[i] - rhs[i]) * predicate as Field + rhs[i];\n    }\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    for i in 0..N {\n        l *= TWO_POW_120;\n        r *= TWO_POW_120;\n        modulus_mod_n *= TWO_POW_120;\n        l += lhs[N - i - 1];\n        r += rhs[N - i - 1];\n        modulus_mod_n += params.modulus[N - i - 1];\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let diff = l - r;\n    let target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let is_equal_modulus: bool = diff == params.modulus;\n    let is_equal_zero: bool = diff.all(|elem| elem == 0);\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn is_zero<let N: u32, let MOD_BITS: u32>(val: [Field; N]) -> bool {\n    val.all(|limb| limb == 0)\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [Field; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = modulus[i] - val[i];\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    p_minus_self[0] += borrow_flags[0] as Field * TWO_POW_120;\n    for i in 1..N - 1 {\n        p_minus_self[i] += (borrow_flags[i] as Field * TWO_POW_120 - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= borrow_flags[N - 2] as Field;\n    validate_in_range::<_, MOD_BITS>(p_minus_self);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N - 1) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [Field; N], rhs: [Field; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (result, carry_flags, borrow_flags) = unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, MOD_BITS>(result);\n\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] - rhs[0] + addend[0] - result[0] - 1\n        + (borrow_flags[0] as Field - carry_flags[0] as Field) * TWO_POW_120;\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n        let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n        let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - prev_borrow_sub_carry\n            + borrow_sub_carry * TWO_POW_120;\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] - rhs[N - 1] + addend[N - 1]\n        - result[N - 1]\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __neg(params, val)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, borrow_flags) = unsafe { __neg_with_flags(params, val) };\n        validate_in_range::<_, MOD_BITS>(result);\n        let modulus = params.modulus;\n        let result_limb =\n            modulus[0] - val[0] - result[0] + (borrow_flags[0] as Field * TWO_POW_120);\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = modulus[i] - val[i] - result[i] - borrow_flags[i - 1] as Field\n                + (borrow_flags[i] as Field * TWO_POW_120);\n            assert(result_limb == 0);\n        }\n        let result_limb =\n            modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __add(params, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, carry_flags, borrow_flags, overflow_modulus) =\n            unsafe { __add_with_flags(params, lhs, rhs) };\n        validate_in_range::<_, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut subtrahend: [Field; N] = [0; N];\n        if (overflow_modulus) {\n            subtrahend = modulus;\n        }\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb =\n            lhs[0] + rhs[0] - subtrahend[0] - result[0] + borrow_sub_carry * TWO_POW_120;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] + rhs[i] - subtrahend[i] - result[i] - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb =\n            lhs[N - 1] + rhs[N - 1] - subtrahend[N - 1] - result[N - 1] - borrow_sub_carry;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __sub(params, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        // a - b = r\n        // p + a - b - r = 0\n        let (result, carry_flags, borrow_flags, underflow) =\n            unsafe { __sub_with_flags(params, lhs, rhs) };\n        validate_in_range::<_, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut addend: [Field; N] = [0; N];\n        if (underflow) {\n            addend = modulus;\n        }\n\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = lhs[0] - rhs[0] + addend[0] - result[0] + borrow_sub_carry * TWO_POW_120;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb =\n            lhs[N - 1] - rhs[N - 1] + addend[N - 1] - result[N - 1] - borrow_sub_carry;\n        assert(result_limb == 0);\n        result\n    }\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[lhs]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[result]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [lhs],\n            [true],\n        );\n    }\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n\n    if !std::runtime::is_unconstrained() {\n        // self / divisor = quotient rounded\n        // quotient * divisor + remainder - self = 0\n        evaluate_quadratic_expression(\n            params,\n            [[quotient]],\n            [[false]],\n            [[divisor]],\n            [[false]],\n            [numerator, remainder],\n            [true, false],\n        );\n        // we need (remainder < divisor)\n        // implies (divisor - remainder > 0)\n        validate_gt::<_, MOD_BITS>(divisor, remainder);\n    }\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/fns/constrained_ops.nr"},"96":{"source":"use crate::utils::split_bits;\n\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n * In this file:\n *\n * __compute_quadratic_expression_with_borrow_flags\n * __add_linear_expression\n * __compute_quadratic_expression_product\n * __compute_quadratic_expression\n * evaluate_quadratic_expression\n */\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\nunconstrained fn __compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N], [Field; 2 * N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let modulus: [Field; N] = params.modulus;\n    let modulus_bits = MOD_BITS;\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        modulus_bits,\n        modulus,\n        params.modulus_u60_x4,\n    );\n    assert(remainder == [0; N]);\n\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] * modulus[j];\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N] = [0; 2 * N];\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    let downshift: Field = 1 / two_pow_120;\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits = (mulout_p[0] - mulout_n[0] + (borrow_flags[0] * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n    flags: [bool; M],\n) -> ([Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [Field; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [Field; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + modulus2[j] - x[i][j];\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn __compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut add: [Field; N] = [0; N];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [Field; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] * rhs[k][j]);\n            }\n        }\n        mulout[i] += add[i];\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        k,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([Field; N], [Field; N], [Field; 2 * N]) = unsafe {\n        __compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [Field; N] = params.double_modulus;\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i];\n                    t0[k][i] += double_modulus[i];\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i];\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i];\n                    t1[k][i] += double_modulus[i];\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i];\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i];\n                t4[i] += double_modulus[i];\n            } else {\n                t4[i] += linear_terms[j][i];\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term = t0[k][i] * t1[k][j] - quotient[i] * params.modulus[j];\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j];\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] * params.modulus[j];\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/fns/expressions.nr"},"99":{"source":"use crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\nuse crate::fns::unconstrained_ops::{__add, __eq, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\n\nglobal TWO_POW_60: u64 = 0x1000000000000000;\n\n/**\n * In this file:\n *\n * __validate_in_field_compute_borrow_flags\n * __validate_gt_remainder\n * __neg_with_flags\n * __add_with_flags\n * __sub_with_flags\n * __barrett_reduction\n * __tonelli_shanks_sqrt\n */\n\npub(crate) unconstrained fn __from_field<let N: u32>(field: Field) -> [Field; N] {\n    // cast the field to a u60 representation\n    let res_u60: U60Repr<N, 2> = U60Repr::from_field(field);\n    let result: [Field; N] = U60Repr::into(res_u60);\n    result\n}\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [Field; N] = params.modulus;\n    flags[0] = modulus[0].lt(val[0]);\n    for i in 1..N - 1 {\n        flags[i] = modulus[i].lt(val[i] + flags[i - 1] as Field);\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N]) {\n    let a_u60: U60Repr<N, 2> = From::from(lhs);\n    let mut b_u60: U60Repr<N, 2> = From::from(rhs);\n\n    let underflow = b_u60.gte(a_u60);\n    assert(underflow == false, \"BigNum::validate_gt check fails\");\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 1;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            // Only set `borrow` and `carry` if they differ\n            if (carry != borrow) {\n                carry_flags[i / 2] = carry as bool;\n                borrow_flags[i / 2] = borrow as bool;\n            }\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> ([Field; N], [bool; N]) {\n    let x_u60: U60Repr<N, 2> = From::from(val);\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut borrow_in: u64 = 0;\n\n    let mut borrow_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let sub_term = x_u60.limbs[i] + borrow_in;\n        let borrow = (sub_term > params.modulus_u60.limbs[i]) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + params.modulus_u60.limbs[i] - sub_term;\n\n        borrow_in = borrow;\n        if ((i & 1) == 1) {\n            borrow_flags[i / 2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = From::from(lhs);\n    let b_u60: U60Repr<N, 2> = From::from(rhs);\n    let add_u60 = a_u60 + b_u60;\n\n    let overflow = add_u60.gte(params.modulus_u60);\n\n    let mut subtrahend_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    if overflow {\n        subtrahend_u60 = params.modulus_u60;\n    }\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + b_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = subtrahend_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            // Only set `borrow` and `carry` if they differ\n            if (carry != borrow) {\n                let idx = (i - 1) / 2;\n                carry_flags[idx] = carry as bool;\n                borrow_flags[idx] = borrow as bool;\n            }\n        }\n    }\n    let result = U60Repr::into(result_u60);\n\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let b_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let underflow = b_u60.gte(a_u60 + U60Repr::one());\n\n    let addend_u60: U60Repr<N, 2> = if underflow {\n        params.modulus_u60\n    } else {\n        U60Repr { limbs: [0; 2 * N] }\n    };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + addend_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            // Only set `borrow` and `carry` if they differ\n            if (carry != borrow) {\n                carry_flags[i / 2] = carry as bool;\n                borrow_flags[i / 2] = borrow as bool;\n            }\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [Field; 2 * N],\n    redc_param: [Field; N],\n    k: u32,\n    modulus: [Field; N],\n    modulus_u60: U60Repr<N, 4>,\n) -> ([Field; N], [Field; N]) {\n    // for each i in 0..(N + N), adds x[i] * redc_param[j] to mulout[i + j] for each j in 0..N\n    let mut mulout: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout[i + j] += x[i] * redc_param[j];\n        }\n    }\n\n    mulout = split_bits::__normalize_limbs(mulout, 3 * N - 1);\n    let mulout_u60: U60Repr<N, 6> = U60Repr::new(mulout);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient_u60 = mulout_u60.shr((k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = quotient_u60.into_field_array();\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] += partial_quotient_full[i] * modulus[j];\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    for i in 0..(N + N) {\n        let (lo, hi) = split_bits::split_120_bits(quotient_mul_modulus_normalized[i]);\n        quotient_mul_modulus_normalized[i] = lo;\n\n        // Propagate higher bits to the next index\n        // TODO: what is faster, leaving this if statement in or out?\n        // (array is size-1 too large so we can tolerate adding 0 into max element)\n        if (i + 1 < N + N) {\n            quotient_mul_modulus_normalized[i + 1] += hi;\n        }\n    }\n\n    let quotient_mul_modulus_u60: U60Repr<N, 4> = U60Repr::new(quotient_mul_modulus_normalized);\n    // convert the input into U60Repr\n    let x_u60: U60Repr<N, 4> = U60Repr::new(x);\n    let mut remainder_u60 = x_u60 - quotient_mul_modulus_u60;\n    // barrett reduction is quirky so might need to remove a few modulus_u60 from the remainder\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n\n    let q: [Field; N] = U60Repr::into(quotient_u60);\n    let r: [Field; N] = U60Repr::into(remainder_u60);\n\n    (q, r)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut target: U60Repr<N, 2> = params.modulus_u60 - U60Repr::one();\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target.limbs[0] & 1) == 1;\n        if (lsb_is_one) {\n            break;\n        }\n        result += 1;\n        target.shr1();\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [Field; N],\n    p_minus_one_over_two: [Field; N],\n) -> (bool, [Field; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [Field; N] = __one();\n    let neg_one = __neg(params, one);\n    let found = __eq(exped, neg_one);\n    let mut result: (bool, [Field; N]) = (found, target);\n    if (!found) {\n        let _target = __add(params, target, one);\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [Field; N] {\n    let mut target: [Field; N] = __one();\n    let p_minus_one_over_two: U60Repr<N, 2> = (params.modulus_u60 - U60Repr::one()).shr(1);\n    let p_minus_one_over_two: [Field; N] = U60Repr::into(p_minus_one_over_two);\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [Field; N],\n    i: u32,\n) -> u32 {\n    let one: [Field; N] = __one();\n    let is_one = __eq(t2m, one);\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/fns/unconstrained_helpers.nr"},"100":{"source":"use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __multiplicative_generator, __primitive_root_log_size,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\n/**\n * In this file:\n *\n * __one\n * __derive_from_seed\n * __eq\n * __is_zero\n * __neg\n * __add\n * __sub\n * __mul_with_quotient\n * __mul\n * __div\n * __udiv_mod\n * __invmod\n * __pow\n * __batch_invert\n * __batch_invert_slice\n */\n\npub(crate) unconstrained fn __one<let N: u32>() -> [Field; N] {\n    let mut limbs: [Field; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [Field; N], rhs: [Field; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [Field; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    limbs: [Field; N],\n) -> [Field; N] {\n    let f: [Field; N] = limbs;\n    let x_u60: U60Repr<N, 2> = U60Repr::from(f);\n    U60Repr::into(params.modulus_u60 - x_u60)\n}\n\npub(crate) unconstrained fn __add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let x_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let y_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let mut z_u60 = x_u60 + y_u60;\n\n    if z_u60.gte(params.modulus_u60) {\n        z_u60 = z_u60 - params.modulus_u60;\n    }\n    U60Repr::into(z_u60)\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    __add(params, lhs, __neg(params, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += lhs[i] * rhs[j];\n        }\n    }\n    let to_reduce = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(\n        to_reduce,\n        params.redc_param,\n        MOD_BITS,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    let inv_divisor = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut quotient_u60: U60Repr<N, 2> = U60Repr::from([0; N]);\n    let mut remainder_u60: U60Repr<N, 2> = U60Repr::from(numerator);\n\n    let mut divisor_u60: U60Repr<N, 2> = U60Repr::from(divisor);\n    let b = divisor_u60;\n\n    let numerator_msb = remainder_u60.get_msb();\n    let divisor_msb = divisor_u60.get_msb();\n    if divisor_msb > numerator_msb {\n        ([0; N], numerator)\n    } else {\n        let mut bit_difference = remainder_u60.get_msb() - divisor_u60.get_msb();\n\n        let mut accumulator_u60: U60Repr<N, 2> = U60Repr::one();\n        divisor_u60 = divisor_u60.shl(bit_difference);\n        accumulator_u60 = accumulator_u60.shl(bit_difference);\n\n        if (divisor_u60.gte(remainder_u60 + U60Repr::one())) {\n            divisor_u60.shr1();\n            accumulator_u60.shr1();\n        }\n        for _ in 0..(N * 120) {\n            if (remainder_u60.gte(b) == false) {\n                break;\n            }\n\n            // we've shunted 'divisor' up to have the same bit length as our remainder.\n            // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n            if (remainder_u60.gte(divisor_u60)) {\n                remainder_u60 -= divisor_u60;\n                // we can use OR here instead of +, as\n                // accumulator is always a nice power of two\n                quotient_u60 = quotient_u60 + accumulator_u60;\n            }\n            divisor_u60.shr1(); // >>= 1;\n            accumulator_u60.shr1(); //  >>= 1;\n        }\n\n        (U60Repr::into(quotient_u60), U60Repr::into(remainder_u60))\n    }\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    let one_u60: U60Repr<N, 2> = U60Repr::one();\n    let exp_u60 = params.modulus_u60 - (one_u60 + one_u60);\n    let exp = U60Repr::into(exp_u60);\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n    exponent: [Field; N],\n) -> [Field; N] {\n    let x: U60Repr<N, 2> = U60Repr::from(exponent);\n\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [Field; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if x.get_bit(num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n) -> [[Field; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut temporaries: [[Field; N]; M] = std::mem::zeroed();\n    for i in 0..M {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[Field; N]; M] = [[0; N]; M];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..M {\n        let idx = M - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]],\n) -> [[Field; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut temporaries: [[Field; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[Field; N]] = [];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result = result.push_front(T0);\n        } else {\n            result = result.push_front([0; N]);\n        };\n    }\n\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [Field; N],\n) -> std::option::Option<[Field; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one_u60: U60Repr<N, 2> = U60Repr::one();\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let mut Q = (params.modulus_u60 - one_u60).shr(primitive_root_log_size - 1);\n    let Q_minus_one_over_two_u60 = (Q - one_u60).shr(2);\n    let Q_minus_one_over_two: [Field; N] = U60Repr::into(Q_minus_one_over_two_u60);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [Field; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut result = Option::none();\n    let one: [Field; N] = __one::<N>();\n    if (__eq(check, one)) {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/fns/unconstrained_ops.nr"},"103":{"source":"use crate::params::BigNumParams;\nuse crate::utils::map::map;\n\nuse crate::fns::{\n    constrained_ops::{\n        add, assert_is_not_equal, conditional_select, derive_from_seed, div, eq, is_zero, mul, neg,\n        sub, udiv, udiv_mod, umod, validate_in_field, validate_in_range,\n    },\n    expressions::{__compute_quadratic_expression, evaluate_quadratic_expression},\n    serialization::{from_be_bytes, to_le_bytes},\n    unconstrained_ops::{\n        __add, __batch_invert, __batch_invert_slice, __derive_from_seed, __div, __eq, __invmod,\n        __is_zero, __mul, __neg, __pow, __sub, __tonelli_shanks_sqrt, __udiv_mod,\n    },\n};\nuse std::ops::{Add, Div, Mul, Neg, Sub};\n\npub struct RuntimeBigNum<let N: u32, let MOD_BITS: u32> {\n    pub limbs: [Field; N],\n    pub params: BigNumParams<N, MOD_BITS>,\n}\n\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNum<N, MOD_BITS> {}\n\n// All functions prefixed `__` are unconstrained!\n// They're not actually decorated as `unconstrained` because to return the `params` (as part of Self) from an `unconstrained` fn would cause range constraints. Instead, each `__` fn wraps a call to an unconstrained fn, so that the already-range-constrained `params` can be inserted into Self after the unconstrained call.\npub(crate) trait RuntimeBigNumTrait<let N: u32, let MOD_BITS: u32>: Neg + Add + Sub + Mul + Div + Eq {\n    fn new(params: BigNumParams<N, MOD_BITS>) -> Self;\n    fn one(params: BigNumParams<N, MOD_BITS>) -> Self;\n    fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self;\n    unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self;\n    fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [Field]) -> Self;\n    fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [Field; N]) -> Self;\n    fn from_be_bytes<let NBytes: u32>(params: BigNumParams<N, MOD_BITS>, x: [u8; NBytes]) -> Self;\n\n    fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes];\n\n    fn modulus(self) -> Self;\n    fn modulus_bits() -> u32;\n    fn num_limbs() -> u32;\n    // pub fn get(self) -> [Field];\n    fn get_limbs(self) -> [Field; N];\n    fn get_limb(self, idx: u32) -> Field;\n    fn set_limb(&mut self, idx: u32, value: Field);\n\n    unconstrained fn __eq(self, other: Self) -> bool;\n    unconstrained fn __is_zero(self) -> bool;\n\n    // unconstrained\n    fn __neg(self) -> Self;\n    // unconstrained\n    fn __add(self, other: Self) -> Self;\n    // unconstrained\n    fn __sub(self, other: Self) -> Self;\n    // unconstrained\n    fn __mul(self, other: Self) -> Self;\n    // unconstrained\n    fn __div(self, other: Self) -> Self;\n    // unconstrained\n    fn __udiv_mod(self, divisor: Self) -> (Self, Self);\n    // unconstrained\n    fn __invmod(self) -> Self;\n    // unconstrained\n    fn __pow(self, exponent: Self) -> Self;\n\n    // unconstrained\n    fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M];\n    unconstrained fn __batch_invert_slice<let M: u32>(to_invert: [Self]) -> [Self];\n\n    fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self>;\n\n    // unconstrained\n    fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self);\n\n    fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    );\n\n    fn eq(lhs: Self, rhs: Self) -> bool {\n        lhs == rhs\n    }\n    fn assert_is_not_equal(self, other: Self);\n    fn validate_in_field(self);\n    fn validate_in_range(self);\n    // pub fn validate_gt(self, lhs: Self, rhs: Self);\n\n    fn udiv_mod(numerator: Self, divisor: Self) -> (Self, Self);\n    fn udiv(numerator: Self, divisor: Self) -> Self;\n    fn umod(numerator: Self, divisor: Self) -> Self;\n\n    fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self;\n    fn is_zero(self) -> bool;\n}\n\nimpl<let N: u32, let MOD_BITS: u32> Neg for RuntimeBigNum<N, MOD_BITS> {\n    fn neg(self) -> Self {\n        let params = self.params;\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNumTrait<N, MOD_BITS> for RuntimeBigNum<N, MOD_BITS> {\n\n    fn new(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let limbs: [Field; N] = [0; N];\n        Self { limbs, params }\n    }\n\n    fn one(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let mut result = RuntimeBigNum::new(params);\n        result.limbs[0] = 1;\n        result\n    }\n\n    fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = __derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [Field]) -> Self {\n        Self { limbs: limbs.as_array(), params }\n    }\n\n    fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [Field; N]) -> Self {\n        Self { limbs, params }\n    }\n\n    fn from_be_bytes<let NBytes: u32>(params: BigNumParams<N, MOD_BITS>, x: [u8; NBytes]) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS, _>(x), params }\n    }\n\n    fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes] {\n        to_le_bytes::<_, MOD_BITS, _>(self.limbs)\n    }\n\n    fn modulus(self) -> Self {\n        let params = self.params;\n        Self { limbs: params.modulus, params }\n    }\n\n    fn modulus_bits() -> u32 {\n        MOD_BITS\n    }\n\n    fn num_limbs() -> u32 {\n        N\n    }\n\n    // fn get(self) -> [Field] {\n    //     self.get_limbs()\n    // }\n\n    fn get_limbs(self) -> [Field; N] {\n        self.limbs\n    }\n\n    fn get_limb(self, idx: u32) -> Field {\n        self.limbs[idx]\n    }\n\n    fn set_limb(&mut self, idx: u32, value: Field) {\n        self.limbs[idx] = value;\n    }\n\n    unconstrained fn __eq(self, other: Self) -> bool {\n        assert(self.params == other.params);\n        __eq(self.limbs, other.limbs)\n    }\n\n    unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __neg(self) -> Self {\n        let params = self.params;\n        let limbs = unsafe { __neg(params, self.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __add(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __sub(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __mul::<_, MOD_BITS>(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        let limbs = unsafe { __div::<_, MOD_BITS>(params, self.limbs, divisor.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = unsafe { __udiv_mod(self.limbs, divisor.limbs) };\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __invmod(self) -> Self {\n        let params = self.params;\n        assert(params.has_multiplicative_inverse);\n        let limbs = unsafe { __invmod::<_, MOD_BITS>(params, self.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __pow(self, exponent: Self) -> Self {\n        let params = self.params;\n        assert(params == exponent.params);\n        let limbs = unsafe { __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs =\n            unsafe { __batch_invert::<_, MOD_BITS, _>(params, x.map(|bn| Self::get_limbs(bn))) };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // Note: can't return a slice from this unconstrained to a constrained function.\n    unconstrained fn __batch_invert_slice<let M: u32>(x: [Self]) -> [Self] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs = {\n            let inv_slice =\n                __batch_invert_slice::<_, MOD_BITS>(params, x.map(|bn| Self::get_limbs(bn)));\n            inv_slice.as_array()\n        };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = self.params;\n        let maybe_limbs = unsafe { __tonelli_shanks_sqrt(params, self.limbs) };\n        maybe_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self) {\n        let (q_limbs, r_limbs) = unsafe {\n            __compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n                params,\n                map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                lhs_flags,\n                map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                rhs_flags,\n                map(linear_terms, |bn| Self::get_limbs(bn)),\n                linear_flags,\n            )\n        };\n        (Self { limbs: q_limbs, params }, Self { limbs: r_limbs, params })\n    }\n\n    fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) {\n        evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            rhs_flags,\n            map(linear_terms, |bn| Self::get_limbs(bn)),\n            linear_flags,\n        )\n    }\n\n    fn validate_in_field(self: Self) {\n        let params = self.params;\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    fn validate_in_range(self) {\n        validate_in_range::<_, MOD_BITS>(self.limbs);\n    }\n\n    fn assert_is_not_equal(self, other: Self) {\n        let params = self.params;\n        assert(params == other.params);\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    fn udiv(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    fn umod(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self {\n        let params = lhs.params;\n        assert(params == rhs.params);\n        Self { limbs: conditional_select(lhs.limbs, rhs.limbs, predicate), params }\n    }\n\n    fn is_zero(self) -> bool {\n        is_zero::<N, MOD_BITS>(self.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Add for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Sub for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Mul for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Div for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for RuntimeBigNum<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        let params = self.params;\n        assert(params == other.params);\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/runtime_bignum.nr"},"109":{"source":"/// Multiple entires in the `MUL_DE_BRUIJN_BIT` list do not map to a valid output of `v * 0x6c04f118e9966f6b`.\n/// This is a dummy value to fill the gaps in the map.\nglobal n1: u32 = 0xffffffff;\n\nglobal MUL_DE_BRUIJN_BIT: [u32; 128] = [\n    0, // change to 1 if you want bitSize(0) = 1\n    48, n1, n1, 31, n1, 15, 51, n1, 63, 5, n1, n1, n1, 19, n1, 23, 28, n1, n1, n1, 40, 36, 46, n1,\n    13, n1, n1, n1, 34, n1, 58, n1, 60, 2, 43, 55, n1, n1, n1, 50, 62, 4, n1, 18, 27, n1, 39, 45,\n    n1, n1, 33, 57, n1, 1, 54, n1, 49, n1, 17, n1, n1, 32, n1, 53, n1, 16, n1, n1, 52, n1, n1, n1,\n    64, 6, 7, 8, n1, 9, n1, n1, n1, 20, 10, n1, n1, 24, n1, 29, n1, n1, 21, n1, 11, n1, n1, 41, n1,\n    25, 37, n1, 47, n1, 30, 14, n1, n1, n1, n1, 22, n1, n1, 35, 12, n1, n1, n1, 59, 42, n1, n1, 61,\n    3, 26, 38, 44, n1, 56,\n];\n\npub unconstrained fn get_msb64(x: u64) -> u32 {\n    let mut v = x;\n    v |= v >> 1;\n    v |= v >> 2;\n    v |= v >> 4;\n    v |= v >> 8;\n    v |= v >> 16;\n    v |= v >> 32;\n    MUL_DE_BRUIJN_BIT[(std::wrapping_mul(v, 0x6c04f118e9966f6b)) >> 57]\n}\n\n// 1100\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/utils/msb.nr"},"110":{"source":"global TWO_POW_56: u64 = 0x100000000000000;\npub(crate) global TWO_POW_60: u64 = 0x1000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n//fields to u60rep conversion\n// field elements are 254 bits\n// so there will be 5 limbs\npub(crate) unconstrained fn field_to_u60rep(mut x: Field) -> (u64, u64, u64, u64, u64) {\n    // get the first 60 bits by casting to u64 and then taking the lower 60 bits\n    // we use the fact that this casting drops everything above 64 bits\n    let x_first_u64 = (x as u64);\n    let first: u64 = x_first_u64 % TWO_POW_60;\n    // this becomes the same as a integer division because we're removing the remainder\n    x = (x - (first as Field)) / (TWO_POW_60 as Field);\n    let x_second_u64 = (x as u64);\n    let second = x_second_u64 % TWO_POW_60;\n    x = (x - (second as Field)) / (TWO_POW_60 as Field);\n    let x_third_u64 = (x as u64);\n    let third = x_third_u64 % TWO_POW_60;\n    x = (x - (third as Field)) / (TWO_POW_60 as Field);\n    let x_fourth_u64 = (x as u64);\n    let fourth = x_fourth_u64 % TWO_POW_60;\n    x = (x - (fourth as Field)) / (TWO_POW_60 as Field);\n    let x_fifth_u64 = (x as u64);\n    let fifth = x_fifth_u64 % TWO_POW_60;\n    (first, second, third, fourth, fifth)\n}\n\n// Decomposes a single field into two 120 bit fields\npub unconstrained fn split_120_bits(mut x: Field) -> (Field, Field) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_56 = ((x as u64) % TWO_POW_56) as Field;\n\n    let low = low_lower_64 + TWO_POW_64 * low_upper_56;\n    let high = (x - low_upper_56) / TWO_POW_56 as Field;\n\n    (low, high)\n}\n\n/// Decomposes a single field into two 60 bit fields\n///\n/// Expects the input limb to be in the range [0, ..., 2^{120 - 1}]\nunconstrained fn __split_60_bits(x: Field) -> (u64, u64) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let x_lower_64 = (x as u64);\n    let low = x_lower_64 % TWO_POW_60;\n    let high = ((x - (low as Field)) / TWO_POW_60 as Field) as u64;\n\n    (low, high)\n}\n\n/// Decomposes a single field into two 60 bit fields\n///\n/// Expects the input limb to be in the range [0, ..., 2^{120 - 1}]\npub fn split_60_bits(x: Field) -> (u64, u64) {\n    // We assert that the two returned limbs fit within 60 bits each\n    // and reconstruct `x` when added together.\n    let (lo, hi) = unsafe { __split_60_bits(x) };\n    if !std::runtime::is_unconstrained() {\n        let lo_field = lo as Field;\n        let hi_field = hi as Field;\n        lo_field.assert_max_bit_size::<60>();\n        hi_field.assert_max_bit_size::<60>();\n        assert_eq(lo_field + (TWO_POW_60 as Field) * hi_field, x);\n    }\n\n    (lo, hi)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [Field; N] {\n    let mut normalized: [Field; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(next);\n\n        normalized[i] = lo;\n        next = input[i + 1] + hi;\n    }\n    {\n        let (lo, hi) = split_120_bits(next);\n        normalized[range - 1] = lo;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/utils/split_bits.nr"},"111":{"source":"use crate::utils::msb::get_msb64;\nuse crate::utils::split_bits;\nuse crate::utils::split_bits::{field_to_u60rep, TWO_POW_60};\n\n/**\n * @brief U60Repr represents a BigNum element as a sequence of 60-bit unsigned integers.\n *\n * @description: used in unconstrained functions when computing witness values.\n * It is helpful to use u60 types when evaluating addition operations that can overflow the field modulus,\n * as well as when performing bit shifts.\n */\npub struct U60Repr<let N: u32, let NumSegments: u32> {\n    pub(crate) limbs: [u64; N * NumSegments],\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Add for U60Repr<N, NumSegments> {\n    fn add(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut carry: u64 = 0;\n        for i in 0..N * NumSegments {\n            let mut add: u64 = self.limbs[i] + b.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            result.limbs[i] = add;\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Sub for U60Repr<N, NumSegments> {\n    fn sub(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut borrow: u64 = 0;\n        let mut borrow_in: u64 = 0;\n\n        for i in 0..N * NumSegments {\n            borrow = ((b.limbs[i] + borrow_in) > self.limbs[i]) as u64;\n            let sub = (borrow << 60) + self.limbs[i] - b.limbs[i] - borrow_in;\n            result.limbs[i] = sub;\n            borrow_in = borrow;\n        }\n\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::convert::From<[Field; N]> for U60Repr<N, NumSegments> {\n    fn from(input: [Field; N]) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..N {\n            let (lo, hi) = split_bits::split_60_bits(input[i]);\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n}\n\n// impl<let N: u32, let NumSegments: u32> std::convert::From<Field> for U60Repr<N, NumSegments> {\n//     fn from(input: Field) -> Self {\n//        let (low, mid, high) =  unsafe { field_to_u60rep(input) } ;\n//         let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n//         let N_u60: u32 = N * NumSegments;\n//         assert(N_u60 >=1, \"N must be at least 1\");\n//         if N_u60 == 1 {\n//             assert((mid ==0) & (high == 0), \"input field is too large to fit in a single limb\");\n//             result.limbs[0] = low;\n//         }\n//         else if N_u60 == 2{\n//             assert(high == 0, \"input field is too large to fit in two limbs\");\n//             result.limbs[0] = low;\n//             result.limbs[1] = mid;\n//         }else{\n//             result.limbs[0] = low;\n//             result.limbs[1] = mid;\n//             result.limbs[2] = high;\n//         }\n//         result\n//     }\n// }\n\nimpl<let N: u32, let NumSegments: u32> std::convert::Into<[Field; N]> for U60Repr<N, NumSegments> {\n    fn into(x: U60Repr<N, NumSegments>) -> [Field; N] {\n        let mut result: [Field; N] = [0; N];\n        let two_pow_60: Field = 0x1000000000000000;\n        for i in 0..N {\n            result[i] = x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * two_pow_60);\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::cmp::Eq for U60Repr<N, NumSegments> {\n    fn eq(self, other: Self) -> bool {\n        self.limbs == other.limbs\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> U60Repr<N, NumSegments> {\n\n    pub(crate) fn new<let NumFieldSegments: u32>(x: [Field; N * NumFieldSegments]) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..(N * NumFieldSegments) {\n            let (lo, hi) = split_bits::split_60_bits(x[i]);\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n\n    pub(crate) fn one() -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub(crate) unconstrained fn from_field(input: Field) -> Self {\n        let (first, second, third, fourth, fifth) = field_to_u60rep(input);\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        let N_u60: u32 = N * NumSegments;\n        assert(N_u60 >= 1, \"N must be at least 1\");\n        if N_u60 == 1 {\n            assert(\n                (second == 0) & (third == 0) & (fourth == 0) & (fifth == 0),\n                \"input field is too large to fit in a single limb\",\n            );\n            result.limbs[0] = first;\n        } else if N_u60 == 2 {\n            assert(\n                (third == 0) & (fourth == 0) & (fifth == 0),\n                \"input field is too large to fit in two limbs\",\n            );\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n        } else if N_u60 == 3 {\n            assert((fourth == 0) & (fifth == 0), \"input field is too large to fit in three limbs\");\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n        } else if N_u60 == 4 {\n            assert((fifth == 0), \"input field is too large to fit in four limbs\");\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n            result.limbs[3] = fourth;\n        } else {\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n            result.limbs[3] = fourth;\n            result.limbs[4] = fifth;\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn into_field_array(\n        x: U60Repr<N, NumSegments>,\n    ) -> [Field; N * NumSegments / 2] {\n        let mut result: [Field; N * NumSegments / 2] = [0; N * NumSegments / 2];\n        for i in 0..(N * NumSegments / 2) {\n            result[i] =\n                x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * TWO_POW_60 as Field);\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn gte(self, b: Self) -> bool {\n        let mut result = false;\n        let mut early_exit = false;\n        for i in 0..(N * NumSegments) {\n            let idx = (N * NumSegments) - 1 - i;\n            if (b.limbs[idx] == self.limbs[idx]) {\n                continue;\n            }\n\n            result = b.limbs[idx] < self.limbs[idx];\n            early_exit = true;\n            break;\n        }\n        if early_exit {\n            result\n        } else {\n            self.limbs[0] == b.limbs[0]\n        }\n    }\n\n    pub(crate) fn get_bit(self, bit: u32) -> bool {\n        let segment_index = bit / 60;\n        let uint_index = bit % 60;\n\n        let limb: u64 = self.limbs[segment_index];\n        let value = (limb >> uint_index as u8) & 1;\n        value == 1\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = (shift % 60) as u8;\n        let remainder_shift = (60 - limb_shift) as u8;\n        let mask: u64 = (((1 as u64) << limb_shift) - 1) << remainder_shift;\n        result.limbs[0] = (self.limbs[0 + num_shifted_limbs] >> limb_shift);\n\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i + num_shifted_limbs];\n            result.limbs[i] = value >> limb_shift;\n            let remainder: u64 = (value << remainder_shift) & mask;\n            result.limbs[i - 1] = result.limbs[i - 1] + remainder;\n        }\n        result\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr1(&mut self) {\n        let mut remainder = 0;\n\n        for i in 0..N * NumSegments {\n            let value = self.limbs[N * NumSegments - 1 - i];\n            self.limbs[N * NumSegments - 1 - i] = (value >> 1) + remainder;\n            remainder = (value & 1) << 59;\n        }\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shl(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; NumSegments * N] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = (shift % 60) as u8;\n        let remainder_shift: u8 = 60 - limb_shift as u8;\n\n        // 83\n        // limb shift = 1\n        // inside shift = 19 bits to the left\n        // meaning we have 19 carry bits and 41 remainder bits\n        let mask: u64 = (1 as u64 << 60) - 1;\n        //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n        let value = self.limbs[0];\n\n        let mut remainder = (value >> remainder_shift);\n        result.limbs[num_shifted_limbs] = (value << limb_shift) & mask;\n\n        // shift 84. num shifted = 1\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i];\n            let upshift = ((value << limb_shift) + remainder) & mask;\n            result.limbs[i + num_shifted_limbs] = upshift;\n            remainder = (value >> remainder_shift);\n            // let remainder: u64 = (self.limbs.get(i + num_shifted_limbs as u64) << remainder_shift as u8) & mask;\n            // result.limbs.set(i - 1, result.limbs.get(i - 1) + remainder);\n        }\n        result\n    }\n\n    pub(crate) fn increment(&mut self) {\n        let mut carry: u64 = 0;\n\n        let mut add: u64 = self.limbs[0] + 1;\n        carry = add >> 60;\n        add = add - (carry << 60);\n        self.limbs[0] = add;\n\n        for i in 1..NumSegments * N {\n            let mut add: u64 = self.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            self.limbs[i] = add;\n        }\n    }\n\n    pub(crate) unconstrained fn get_msb(val: Self) -> u32 {\n        let mut count = 0;\n        for i in 0..N * NumSegments {\n            let v = val.limbs[((N * NumSegments) - 1 - i)];\n            if (v > 0) {\n                count = 60 * ((N * NumSegments) - 1 - i) + get_msb64(v);\n                break;\n            }\n        }\n        count\n    }\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/utils/u60_representation.nr"},"113":{"source":"use dep::bignum::{params::BigNumParams, RuntimeBigNum};\n\npub fn encrypt<let Tau: u32, let Num: u32, let Bits: u32>(\n    params: BigNumParams<Num, Bits>,\n    key_set: [[Field; Num]; Tau + 1],\n    entropy: [bool; Tau],\n    message: bool,\n) -> RuntimeBigNum<Num, Bits> {\n    let mut terms = Vec::new();\n    for i in 0..Tau {\n        terms.push(\n            if entropy[i] {\n                RuntimeBigNum::from_array(params, key_set[i+1])\n            } else {\n                RuntimeBigNum::new(params)\n            }\n        );\n    }\n    let mut sum = unsafe { terms.slice.reduce(|sum, next| sum.__add(next)) };\n\n    let mut flags = [false; Tau + 1];\n    flags[Tau] = true;\n    terms.push(sum);\n\n    RuntimeBigNum::evaluate_quadratic_expression(\n        params,\n        [[]; 0],\n        [[]; 0],\n        [[]; 0],\n        [[]; 0],\n        terms.slice.as_array(),\n        flags,\n    );\n\n    if message {\n        let _1 = RuntimeBigNum::one(params);\n        let _2 = _1 + _1;\n        sum += RuntimeBigNum::from_array(params, key_set[1]).udiv(_2);\n    }\n    sum\n}\n\npub fn decrypt<let Limbs: u32, let Bits: u32>(\n    decryption_key: RuntimeBigNum<Limbs, Bits>,\n    ciphertext: RuntimeBigNum<Limbs, Bits>,\n) -> bool {\n    let _1 = RuntimeBigNum::one(ciphertext.params);\n    let _2 = _1 + _1;\n\n    let k = decryption_key;\n    let c = ciphertext;\n\n    // round_nearest(2*c/k)%2 == 1\n    (c.udiv(k) * _2 + (k.udiv(_2) + c.umod(k) * _2).udiv(k)).umod(_2) == _1\n}\n\n#[test]\nfn test_encrypt_decrypt() {\n    let dec_key_limbs = [1, 4, 2, 8, 5, 7, 0, 0, 0];\n    let dec_key = RuntimeBigNum::from_array(MC1031_params, dec_key_limbs);\n    let enc_key = [dec_key_limbs; 1289 + 1];\n    let mut entropy = [false; 1289];\n    for i in 0..123 {\n        entropy[(i * 456) % 1289 + 1] = true;\n    }\n\n    assert(decrypt(dec_key, encrypt(MC1031_params, enc_key, entropy, true)) == true);\n    assert(decrypt(dec_key, encrypt(MC1031_params, enc_key, entropy, false)) == false);\n}\n\n/* Old implementations using BigNums fixed since compile time */\n// TODO: cleaning up and refactoring in progress\n\n/*\nfn decrypt_noise(p: AGCD, c: AGCD) -> AGCD {\n    let _1: AGCD = BigNum::one();\n    let _2 = _1 + _1;\n\n    // ~ c%(p/2)\n    c.umod(p.udiv(_2))\n}\n\n\n\n// (Harcoded for security parameter=128)\npub fn validate_keypair<let Tau: u32>(\n    common_divisor_entropy: [Field; 8],\n    multiplier_entropy: [[Field; 2]; Tau + 1],\n    additive_entropy: [[Field; 2]; Tau + 1],\n    resulting_samples: [[Field; 9]; Tau + 1],\n) {\n    // Assert that p has 128*7 bits or less\n    let TWO_POW_120 = 0x1_00000_00000_00000_00000_00000_00000;\n    for i in 0..7 {\n        assert(common_divisor_entropy[i].lt(TWO_POW_120));\n    }\n    let TWO_POW_56 = 0x10000_00000_00000;\n    assert(common_divisor_entropy[7].lt(TWO_POW_56));\n\n    let mut decryption_key_limbs = [0; 9];\n    for i in 0..8 {\n        decryption_key_limbs[i] = common_divisor_entropy[i];\n    }\n    let decryption_key: MC1031 = BigNum::from_slice(decryption_key_limbs);\n\n    for i in 0..Tau + 1 {\n        // Assert that q's have 128+7 bits or less\n        assert(multiplier_entropy[i][0].lt(TWO_POW_120));\n        assert(multiplier_entropy[i][1].lt((2 << 15) as Field));\n\n        // Assert that r's have 128 bits or less\n        assert(additive_entropy[i][0].lt(TWO_POW_120));\n        assert(additive_entropy[i][1].lt((2 << 8) as Field));\n\n        let mut multiplier_limbs = [0; 9];\n        multiplier_limbs[0] = multiplier_entropy[i][0];\n        multiplier_limbs[1] = multiplier_entropy[i][1];\n        let multiplier = BigNum::from_slice(multiplier_limbs);\n\n        let mut added_noise_limbs = [0; 9];\n        added_noise_limbs[0] = additive_entropy[i][0];\n        added_noise_limbs[1] = additive_entropy[i][1];\n        let added_noise = BigNum::from_slice(added_noise_limbs);\n        let TWO_POW_127 = BigNum::from_slice([0, 0x80, 0, 0, 0, 0, 0, 0, 0]);\n\n        assert(\n            resulting_samples[i] == (decryption_key * multiplier + added_noise - TWO_POW_127).limbs,\n        );\n    }\n}\n*/\n\n/*\n#[test]\nfn uniform_noise_potential_detector() {\n    let _1: AGCD = BigNum::one();\n    let _2 = _1 + _1;\n\n    let dk = BigNum::from_slice([1, 4, 2, 8, 5, 7, 0, 0, 0]);\n    let ek = [dk + _1; OLD_TAU];\n    let mut entropy = [false; OLD_TAU];\n    for i in 0..15 {\n        entropy[(i * 7) % OLD_TAU] = true;\n    }\n    let real_noise = decrypt_noise(dk, encrypt(ek, entropy, true));\n    let fake_noise = decrypt_noise(dk, BigNum::from_slice([4, 4, 6, 2, 6, 7, 4, 2, 2]));\n    println(f\"real_noise: {real_noise}\");\n    println(f\"fake_noise: {fake_noise}\");\n}\n*/\n\n// Maximum Cyphertext considered (integers modulo 2^1031)\nglobal MC1031_params: BigNumParams<9, 1031> = BigNumParams {\n    modulus: [\n        0xffffffffffffffffffffffffffffff,\n        0xffffffffffffffffffffffffffffff,\n        0xffffffffffffffffffffffffffffff,\n        0xffffffffffffffffffffffffffffff,\n        0xffffffffffffffffffffffffffffff,\n        0xffffffffffffffffffffffffffffff,\n        0xffffffffffffffffffffffffffffff,\n        0xffffffffffffffffffffffffffffff,\n        0x7fffffffffffffffff,\n    ],\n    double_modulus: [\n        0x01fffffffffffffffffffffffffffffe,\n        0x01fffffffffffffffffffffffffffffe,\n        0x01fffffffffffffffffffffffffffffe,\n        0x01fffffffffffffffffffffffffffffe,\n        0x01fffffffffffffffffffffffffffffe,\n        0x01fffffffffffffffffffffffffffffe,\n        0x01fffffffffffffffffffffffffffffe,\n        0x01fffffffffffffffffffffffffffffe,\n        0xfffffffffffffffffe,\n    ],\n    modulus_u60: U60Repr {\n        limbs: [\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x07ff,\n        ],\n    },\n    modulus_u60_x4: U60Repr {\n        limbs: [\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x07ff,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n        ],\n    },\n    redc_param: [0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08000000000000000000],\n    has_multiplicative_inverse: false,\n};\nuse dep::bignum::utils::u60_representation::U60Repr;\n","path":"/root/box/terry-escape/packages/noir/libs/cheon_stehle/src/lib.nr"}},"names":["main"],"brillig_names":["decompose_hint","__add_with_flags","__udiv_mod","__compute_quadratic_expression_with_borrow_flags","__validate_gt_remainder","__mul","__compute_quadratic_expression_with_borrow_flags","__sub_with_flags","output_detect","output_board","directive_invert"]}