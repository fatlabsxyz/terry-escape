{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":3153093604470314110,"abi":{"parameters":[{"name":"board_used","type":{"kind":"array","length":16,"type":{"kind":"field"}},"visibility":"private"},{"name":"old_board_salt","type":{"kind":"field"},"visibility":"private"},{"name":"new_board_salt","type":{"kind":"field"},"visibility":"private"},{"name":"reason","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"target","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"trap","type":{"kind":"boolean"},"visibility":"private"},{"name":"action_salt","type":{"kind":"field"},"visibility":"private"},{"name":"params","type":{"kind":"struct","path":"bignum::params::BigNumParams","fields":[{"name":"has_multiplicative_inverse","type":{"kind":"boolean"}},{"name":"modulus","type":{"kind":"array","length":9,"type":{"kind":"field"}}},{"name":"modulus_u60","type":{"kind":"struct","path":"bignum::utils::u60_representation::U60Repr","fields":[{"name":"limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":64}}}]}},{"name":"modulus_u60_x4","type":{"kind":"struct","path":"bignum::utils::u60_representation::U60Repr","fields":[{"name":"limbs","type":{"kind":"array","length":36,"type":{"kind":"integer","sign":"unsigned","width":64}}}]}},{"name":"double_modulus","type":{"kind":"array","length":9,"type":{"kind":"field"}}},{"name":"redc_param","type":{"kind":"array","length":9,"type":{"kind":"field"}}}]},"visibility":"private"},{"name":"decryption_key","type":{"kind":"array","length":9,"type":{"kind":"field"}},"visibility":"private"},{"name":"hit_reports","type":{"kind":"array","length":3,"type":{"kind":"array","length":9,"type":{"kind":"field"}}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"field"},{"kind":"field"},{"kind":"field"},{"kind":"boolean"},{"kind":"field"}]},"visibility":"public"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13265554733035650515":{"error_kind":"string","string":"BigNum::validate_gt check fails"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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dteNa3fduHbXjWt3XVq769LaXZfW7rq0dtfVfz1LX/prd11au+vS2l2X1u66tHbXTWt33bR2101rd920dtfVf/VLX/prd920dtdNa3fdtHbXTWt3XV676/LaXZfX7rq8dtfVf61MX/prd11eu+vy2l2X1+66vHbXlbW7rqzddWXtritrd13918r0pb9215W1u66s3XVl7a4ra3fdvHbXzWt33bx2181rd139N0L1pb92181rd130d1PV6K/ddeHfTXVPH/7dVBX6a3dd+HdTVeiv3XXXfjcVrf1uKlr73VS09rupaO13U9Ha76ZKa7+bKq39bqq09rup0trvpkpu6a6b1n43VVr73VRp7XdTJfT381B4fMVaiMOZPnjsH9+SF5Z0po8U+x+EkKL5gxDSqvCDENI67xchqDetfBBCWot9ENKvcSmFB6GU/X2RSDk+Ps6w/ZlPRWLC21C60qe16ae16fPa9GVt+nlt+mVp+hPehtKVvl+b/tpdN67ddSe8DaUr/bW7bly768a1u25cu+sSet3Pj+/rpOLOWzIEXnmKzzv9IGf6SJXngxBSLfkghFQdPgjp57ukfcNB0plQASM04V0JFUIejVBAIxTRCBEaoYRGiNEICRohtEqd0Co1o1VqRqvUjFapGa1SM1qlnnD3Oe8fAd3+PD0R0r/RWVx+PAkurpwspH9LsJA8fl2259AnQuq9rGzK7EGI4/c+J5/07/31pZ/Xpl+Wpq9/768vfb82/bA2/bg2fVqbflqb/tpdN6/ddfPaXTev3XXL2l23rN11y9pdt6zddfXv/fWlv3bXLeB1Xyju9Dn+kz478MqT5fG4O5az9dkhVZ4PQki15IMQUnX4IKSf7+IeQVQkhG/lO+vfOOpLX9amn9emX5am793a9P3a9MPa9OPa9Glt+mt3Xb921/Vrd12/dtf1a3fdsHbXDWt33bB21w1rd139+5996YPX/crmUASvPJXNoYhUeT4IIdWSD0JI1eGD0IR8368HFMmVV3J4Xx5vFNn+5HPEpbXp89r0ZW36eW36ZWn65Nam79emH9amH9emv3bXpbW7Lq3ddWntrktrd11au+umtbtuWrvrprW7blq76+rfif0a/ZB3+iFf0AfvujX64F23Qp/BC2d0j41RHwOd6YOnLpXHlUSfXDrTR0rdD0JIyfhBCCm9PgghLVM/CCEt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","file_map":{"3":{"source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n}\n","path":"std/array/mod.nr"},"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"12":{"source":"// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n","path":"std/convert.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"20":{"source":"pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"29":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n}\n","path":"std/lib.nr"},"61":{"source":"use bignum::params::BigNumParams;\nuse bignum::RuntimeBigNum::from_array;\nuse cheon_stehle::decrypt;\nuse std::hash::pedersen_hash as hash;\n\nglobal Players: u32 = 4;\nglobal Size: u32 = 16;\nglobal Limbs: u32 = 9;\nglobal Bits: u32 = 1031;\n\nfn tile_has_trap(tile: Field) -> bool {\n    tile == 0\n}\nfn tile_has_agent(tile: Field) -> bool {\n    (tile != 0) & (tile != 1)\n}\n\n\n#[oracle(oracle_board)]\nunconstrained fn oracle_board(board: [Field; Size]) -> () {}\nunconstrained fn output_board(board: [Field; Size]) -> () {\n    oracle_board(board);\n}\n#[oracle(oracle_detect)]\nunconstrained fn oracle_detect(detect: u32) -> () {}\nunconstrained fn output_detect(detect: u32) -> () {\n    oracle_detect(detect);\n}\n\nfn main(\n    mut board_used: [Field; Size],\n    old_board_salt: Field,\n    new_board_salt: Field,\n    reason: u32,\n    target: u32,\n    trap: bool,\n    action_salt: Field,\n    params: BigNumParams<Limbs, Bits>,\n    decryption_key: [Field; Limbs],\n    hit_reports: [[Field; Limbs]; Players - 1],\n) -> pub (Field, Field, Field, bool, Field) {\n    let old_board_digest = hash([old_board_salt, hash(board_used)]);\n    let action_digest = hash(\n        [action_salt, reason as Field, target as Field, trap as Field],\n    );\n\n    let decryption_key_digest = hash(decryption_key);\n    let dk = from_array(params, decryption_key);\n    let detect = hit_reports.any(|encrypted_report| {\n        decrypt(dk, from_array(params, encrypted_report))\n    })\n        | (trap & tile_has_agent(board_used[target]))\n        | tile_has_trap(board_used[target]);\n\n    if trap {\n        board_used[target] = 0; // Trap\n    } else {\n        board_used[reason] -= 1; // Decrement agents\n        board_used[target] += 1; // Increment agents\n    }\n    if detect {\n        board_used[target] = 1; // Void tile\n        let _ = unsafe { output_detect(target) };\n    }\n\n    let _ = unsafe { output_board(board_used) };\n    let new_board_digest = hash([new_board_salt, hash(board_used)]);\n    let ded = board_used.all(|v| (v == 0) | (v == 1));\n\n    (old_board_digest, new_board_digest, action_digest, ded, decryption_key_digest)\n}\n","path":"/root/box/terry-escape/packages/noir/circuits/reports_updates/src/main.nr"},"95":{"source":"use crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__add, __div, __mul, __neg, __sub, __udiv_mod},\n};\nuse crate::params::BigNumParams as P;\n\nglobal TWO_POW_120: Field = 0x1000000000000000000000000000000;\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n */\n\npub(crate) fn limbs_to_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    limbs: [Field; N],\n) -> Field {\n    let TWO_POW_120 = 0x1000000000000000000000000000000;\n    if N > 2 {\n        // validate that the limbs is less than the modulus the grumpkin modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, MOD_BITS>(grumpkin_modulus, limbs);\n        // validate that the limbs are in range\n        validate_in_range::<N, MOD_BITS>(limbs);\n    }\n    // validate the limbs sum up to the field value\n    if N < 2 {\n        limbs[0]\n    } else if N == 2 {\n        validate_in_range::<N, MOD_BITS>(limbs);\n        limbs[0] + limbs[1] * TWO_POW_120\n    } else {\n        // validate_in_range::<N, 254>(limbs);\n        limbs[0] + limbs[1] * TWO_POW_120 + limbs[2] * TWO_POW_120 * TWO_POW_120\n    }\n}\n\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    field: Field,\n) -> [Field; N] {\n    // Safety: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result = unsafe { __from_field::<N>(field) };\n\n    if !std::runtime::is_unconstrained() {\n        // validate the limbs are in range and the value in total is less than 2^254\n\n        let TWO_POW_120 = 0x1000000000000000000000000000000;\n        // validate that the last limb is less than the modulus\n        if N > 2 {\n            // validate that the result is less than the modulus\n            let mut grumpkin_modulus = [0; N];\n            grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n            grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n            grumpkin_modulus[2] = 0x3064;\n            validate_gt::<N, MOD_BITS>(grumpkin_modulus, result);\n            // validate that the limbs are in range\n            validate_in_range::<N, MOD_BITS>(result);\n        }\n        // validate the limbs sum up to the field value\n        let field_val = if N < 2 {\n            result[0]\n        } else if N == 2 {\n            validate_in_range::<N, MOD_BITS>(result);\n            result[0] + result[1] * TWO_POW_120\n        } else {\n            validate_in_range::<N, MOD_BITS>(result);\n            result[0] + result[1] * TWO_POW_120 + result[2] * TWO_POW_120 * TWO_POW_120\n        };\n        assert(field_val == field);\n    }\n\n    result\n}\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        std::hash::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[Field; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [Field; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n        let mut num_remaining_limbs =\n            (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n        let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n        let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n            + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n        for j in 0..num_limbs_in_bigfield {\n            let mut limb: Field = 0;\n            for _ in 0..15 {\n                let need_more_bytes = (byte_ptr < num_bytes);\n                let mut byte = hash_buffer[byte_ptr];\n                limb *= (256 * need_more_bytes as Field + (1 - need_more_bytes as Field));\n                limb += byte as Field * need_more_bytes as Field;\n                byte_ptr += need_more_bytes as u32;\n            }\n            bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n        }\n        bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n    }\n\n    let mut bigfield_rhs_limbs: [Field; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [Field; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n    result\n}\n\n/**\n* @brief conditional_select given the value of `predicate` return either `self` (if 0) or `other` (if 1)\n* @description should be cheaper than using an IF statement (TODO: check!)\n**/\npub(crate) fn conditional_select<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n    predicate: bool,\n) -> [Field; N] {\n    let mut result: [Field; N] = lhs;\n    for i in 0..N {\n        result[i] = (lhs[i] - rhs[i]) * predicate as Field + rhs[i];\n    }\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    for i in 0..N {\n        l *= TWO_POW_120;\n        r *= TWO_POW_120;\n        modulus_mod_n *= TWO_POW_120;\n        l += lhs[N - i - 1];\n        r += rhs[N - i - 1];\n        modulus_mod_n += params.modulus[N - i - 1];\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let diff = l - r;\n    let target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let is_equal_modulus: bool = diff == params.modulus;\n    let is_equal_zero: bool = diff.all(|elem| elem == 0);\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn is_zero<let N: u32, let MOD_BITS: u32>(val: [Field; N]) -> bool {\n    val.all(|limb| limb == 0)\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [Field; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = modulus[i] - val[i];\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    p_minus_self[0] += borrow_flags[0] as Field * TWO_POW_120;\n    for i in 1..N - 1 {\n        p_minus_self[i] += (borrow_flags[i] as Field * TWO_POW_120 - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= borrow_flags[N - 2] as Field;\n    validate_in_range::<_, MOD_BITS>(p_minus_self);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N - 1) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [Field; N], rhs: [Field; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (result, carry_flags, borrow_flags) = unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, MOD_BITS>(result);\n\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] - rhs[0] + addend[0] - result[0] - 1\n        + (borrow_flags[0] as Field - carry_flags[0] as Field) * TWO_POW_120;\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n        let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n        let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - prev_borrow_sub_carry\n            + borrow_sub_carry * TWO_POW_120;\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] - rhs[N - 1] + addend[N - 1]\n        - result[N - 1]\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __neg(params, val)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, borrow_flags) = unsafe { __neg_with_flags(params, val) };\n        validate_in_range::<_, MOD_BITS>(result);\n        let modulus = params.modulus;\n        let result_limb =\n            modulus[0] - val[0] - result[0] + (borrow_flags[0] as Field * TWO_POW_120);\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = modulus[i] - val[i] - result[i] - borrow_flags[i - 1] as Field\n                + (borrow_flags[i] as Field * TWO_POW_120);\n            assert(result_limb == 0);\n        }\n        let result_limb =\n            modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __add(params, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, carry_flags, borrow_flags, overflow_modulus) =\n            unsafe { __add_with_flags(params, lhs, rhs) };\n        validate_in_range::<_, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut subtrahend: [Field; N] = [0; N];\n        if (overflow_modulus) {\n            subtrahend = modulus;\n        }\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb =\n            lhs[0] + rhs[0] - subtrahend[0] - result[0] + borrow_sub_carry * TWO_POW_120;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] + rhs[i] - subtrahend[i] - result[i] - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb =\n            lhs[N - 1] + rhs[N - 1] - subtrahend[N - 1] - result[N - 1] - borrow_sub_carry;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __sub(params, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        // a - b = r\n        // p + a - b - r = 0\n        let (result, carry_flags, borrow_flags, underflow) =\n            unsafe { __sub_with_flags(params, lhs, rhs) };\n        validate_in_range::<_, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut addend: [Field; N] = [0; N];\n        if (underflow) {\n            addend = modulus;\n        }\n\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = lhs[0] - rhs[0] + addend[0] - result[0] + borrow_sub_carry * TWO_POW_120;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb =\n            lhs[N - 1] - rhs[N - 1] + addend[N - 1] - result[N - 1] - borrow_sub_carry;\n        assert(result_limb == 0);\n        result\n    }\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[lhs]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[result]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [lhs],\n            [true],\n        );\n    }\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n\n    if !std::runtime::is_unconstrained() {\n        // self / divisor = quotient rounded\n        // quotient * divisor + remainder - self = 0\n        evaluate_quadratic_expression(\n            params,\n            [[quotient]],\n            [[false]],\n            [[divisor]],\n            [[false]],\n            [numerator, remainder],\n            [true, false],\n        );\n        // we need (remainder < divisor)\n        // implies (divisor - remainder > 0)\n        validate_gt::<_, MOD_BITS>(divisor, remainder);\n    }\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/fns/constrained_ops.nr"},"96":{"source":"use crate::utils::split_bits;\n\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n * In this file:\n *\n * __compute_quadratic_expression_with_borrow_flags\n * __add_linear_expression\n * __compute_quadratic_expression_product\n * __compute_quadratic_expression\n * evaluate_quadratic_expression\n */\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\nunconstrained fn __compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N], [Field; 2 * N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let modulus: [Field; N] = params.modulus;\n    let modulus_bits = MOD_BITS;\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        modulus_bits,\n        modulus,\n        params.modulus_u60_x4,\n    );\n    assert(remainder == [0; N]);\n\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] * modulus[j];\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N] = [0; 2 * N];\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    let downshift: Field = 1 / two_pow_120;\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits = (mulout_p[0] - mulout_n[0] + (borrow_flags[0] * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n    flags: [bool; M],\n) -> ([Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [Field; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [Field; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + modulus2[j] - x[i][j];\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn __compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut add: [Field; N] = [0; N];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [Field; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] * rhs[k][j]);\n            }\n        }\n        mulout[i] += add[i];\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        k,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([Field; N], [Field; N], [Field; 2 * N]) = unsafe {\n        __compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [Field; N] = params.double_modulus;\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i];\n                    t0[k][i] += double_modulus[i];\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i];\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i];\n                    t1[k][i] += double_modulus[i];\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i];\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i];\n                t4[i] += double_modulus[i];\n            } else {\n                t4[i] += linear_terms[j][i];\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term = t0[k][i] * t1[k][j] - quotient[i] * params.modulus[j];\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j];\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] * params.modulus[j];\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/fns/expressions.nr"},"99":{"source":"use crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\nuse crate::fns::unconstrained_ops::{__add, __eq, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\n\nglobal TWO_POW_60: u64 = 0x1000000000000000;\n\n/**\n * In this file:\n *\n * __validate_in_field_compute_borrow_flags\n * __validate_gt_remainder\n * __neg_with_flags\n * __add_with_flags\n * __sub_with_flags\n * __barrett_reduction\n * __tonelli_shanks_sqrt\n */\n\npub(crate) unconstrained fn __from_field<let N: u32>(field: Field) -> [Field; N] {\n    // cast the field to a u60 representation\n    let res_u60: U60Repr<N, 2> = U60Repr::from_field(field);\n    let result: [Field; N] = U60Repr::into(res_u60);\n    result\n}\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [Field; N] = params.modulus;\n    flags[0] = modulus[0].lt(val[0]);\n    for i in 1..N - 1 {\n        flags[i] = modulus[i].lt(val[i] + flags[i - 1] as Field);\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N]) {\n    let a_u60: U60Repr<N, 2> = From::from(lhs);\n    let mut b_u60: U60Repr<N, 2> = From::from(rhs);\n\n    let underflow = b_u60.gte(a_u60);\n    assert(underflow == false, \"BigNum::validate_gt check fails\");\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 1;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            // Only set `borrow` and `carry` if they differ\n            if (carry != borrow) {\n                carry_flags[i / 2] = carry as bool;\n                borrow_flags[i / 2] = borrow as bool;\n            }\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> ([Field; N], [bool; N]) {\n    let x_u60: U60Repr<N, 2> = From::from(val);\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut borrow_in: u64 = 0;\n\n    let mut borrow_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let sub_term = x_u60.limbs[i] + borrow_in;\n        let borrow = (sub_term > params.modulus_u60.limbs[i]) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + params.modulus_u60.limbs[i] - sub_term;\n\n        borrow_in = borrow;\n        if ((i & 1) == 1) {\n            borrow_flags[i / 2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = From::from(lhs);\n    let b_u60: U60Repr<N, 2> = From::from(rhs);\n    let add_u60 = a_u60 + b_u60;\n\n    let overflow = add_u60.gte(params.modulus_u60);\n\n    let mut subtrahend_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    if overflow {\n        subtrahend_u60 = params.modulus_u60;\n    }\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + b_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = subtrahend_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            // Only set `borrow` and `carry` if they differ\n            if (carry != borrow) {\n                let idx = (i - 1) / 2;\n                carry_flags[idx] = carry as bool;\n                borrow_flags[idx] = borrow as bool;\n            }\n        }\n    }\n    let result = U60Repr::into(result_u60);\n\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let b_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let underflow = b_u60.gte(a_u60 + U60Repr::one());\n\n    let addend_u60: U60Repr<N, 2> = if underflow {\n        params.modulus_u60\n    } else {\n        U60Repr { limbs: [0; 2 * N] }\n    };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + addend_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            // Only set `borrow` and `carry` if they differ\n            if (carry != borrow) {\n                carry_flags[i / 2] = carry as bool;\n                borrow_flags[i / 2] = borrow as bool;\n            }\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [Field; 2 * N],\n    redc_param: [Field; N],\n    k: u32,\n    modulus: [Field; N],\n    modulus_u60: U60Repr<N, 4>,\n) -> ([Field; N], [Field; N]) {\n    // for each i in 0..(N + N), adds x[i] * redc_param[j] to mulout[i + j] for each j in 0..N\n    let mut mulout: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout[i + j] += x[i] * redc_param[j];\n        }\n    }\n\n    mulout = split_bits::__normalize_limbs(mulout, 3 * N - 1);\n    let mulout_u60: U60Repr<N, 6> = U60Repr::new(mulout);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient_u60 = mulout_u60.shr((k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = quotient_u60.into_field_array();\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] += partial_quotient_full[i] * modulus[j];\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    for i in 0..(N + N) {\n        let (lo, hi) = split_bits::split_120_bits(quotient_mul_modulus_normalized[i]);\n        quotient_mul_modulus_normalized[i] = lo;\n\n        // Propagate higher bits to the next index\n        // TODO: what is faster, leaving this if statement in or out?\n        // (array is size-1 too large so we can tolerate adding 0 into max element)\n        if (i + 1 < N + N) {\n            quotient_mul_modulus_normalized[i + 1] += hi;\n        }\n    }\n\n    let quotient_mul_modulus_u60: U60Repr<N, 4> = U60Repr::new(quotient_mul_modulus_normalized);\n    // convert the input into U60Repr\n    let x_u60: U60Repr<N, 4> = U60Repr::new(x);\n    let mut remainder_u60 = x_u60 - quotient_mul_modulus_u60;\n    // barrett reduction is quirky so might need to remove a few modulus_u60 from the remainder\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n\n    let q: [Field; N] = U60Repr::into(quotient_u60);\n    let r: [Field; N] = U60Repr::into(remainder_u60);\n\n    (q, r)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut target: U60Repr<N, 2> = params.modulus_u60 - U60Repr::one();\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target.limbs[0] & 1) == 1;\n        if (lsb_is_one) {\n            break;\n        }\n        result += 1;\n        target.shr1();\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [Field; N],\n    p_minus_one_over_two: [Field; N],\n) -> (bool, [Field; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [Field; N] = __one();\n    let neg_one = __neg(params, one);\n    let found = __eq(exped, neg_one);\n    let mut result: (bool, [Field; N]) = (found, target);\n    if (!found) {\n        let _target = __add(params, target, one);\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [Field; N] {\n    let mut target: [Field; N] = __one();\n    let p_minus_one_over_two: U60Repr<N, 2> = (params.modulus_u60 - U60Repr::one()).shr(1);\n    let p_minus_one_over_two: [Field; N] = U60Repr::into(p_minus_one_over_two);\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [Field; N],\n    i: u32,\n) -> u32 {\n    let one: [Field; N] = __one();\n    let is_one = __eq(t2m, one);\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/fns/unconstrained_helpers.nr"},"100":{"source":"use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __multiplicative_generator, __primitive_root_log_size,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\n/**\n * In this file:\n *\n * __one\n * __derive_from_seed\n * __eq\n * __is_zero\n * __neg\n * __add\n * __sub\n * __mul_with_quotient\n * __mul\n * __div\n * __udiv_mod\n * __invmod\n * __pow\n * __batch_invert\n * __batch_invert_slice\n */\n\npub(crate) unconstrained fn __one<let N: u32>() -> [Field; N] {\n    let mut limbs: [Field; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [Field; N], rhs: [Field; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [Field; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    limbs: [Field; N],\n) -> [Field; N] {\n    let f: [Field; N] = limbs;\n    let x_u60: U60Repr<N, 2> = U60Repr::from(f);\n    U60Repr::into(params.modulus_u60 - x_u60)\n}\n\npub(crate) unconstrained fn __add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let x_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let y_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let mut z_u60 = x_u60 + y_u60;\n\n    if z_u60.gte(params.modulus_u60) {\n        z_u60 = z_u60 - params.modulus_u60;\n    }\n    U60Repr::into(z_u60)\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    __add(params, lhs, __neg(params, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += lhs[i] * rhs[j];\n        }\n    }\n    let to_reduce = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(\n        to_reduce,\n        params.redc_param,\n        MOD_BITS,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    let inv_divisor = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut quotient_u60: U60Repr<N, 2> = U60Repr::from([0; N]);\n    let mut remainder_u60: U60Repr<N, 2> = U60Repr::from(numerator);\n\n    let mut divisor_u60: U60Repr<N, 2> = U60Repr::from(divisor);\n    let b = divisor_u60;\n\n    let numerator_msb = remainder_u60.get_msb();\n    let divisor_msb = divisor_u60.get_msb();\n    if divisor_msb > numerator_msb {\n        ([0; N], numerator)\n    } else {\n        let mut bit_difference = remainder_u60.get_msb() - divisor_u60.get_msb();\n\n        let mut accumulator_u60: U60Repr<N, 2> = U60Repr::one();\n        divisor_u60 = divisor_u60.shl(bit_difference);\n        accumulator_u60 = accumulator_u60.shl(bit_difference);\n\n        if (divisor_u60.gte(remainder_u60 + U60Repr::one())) {\n            divisor_u60.shr1();\n            accumulator_u60.shr1();\n        }\n        for _ in 0..(N * 120) {\n            if (remainder_u60.gte(b) == false) {\n                break;\n            }\n\n            // we've shunted 'divisor' up to have the same bit length as our remainder.\n            // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n            if (remainder_u60.gte(divisor_u60)) {\n                remainder_u60 -= divisor_u60;\n                // we can use OR here instead of +, as\n                // accumulator is always a nice power of two\n                quotient_u60 = quotient_u60 + accumulator_u60;\n            }\n            divisor_u60.shr1(); // >>= 1;\n            accumulator_u60.shr1(); //  >>= 1;\n        }\n\n        (U60Repr::into(quotient_u60), U60Repr::into(remainder_u60))\n    }\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    let one_u60: U60Repr<N, 2> = U60Repr::one();\n    let exp_u60 = params.modulus_u60 - (one_u60 + one_u60);\n    let exp = U60Repr::into(exp_u60);\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n    exponent: [Field; N],\n) -> [Field; N] {\n    let x: U60Repr<N, 2> = U60Repr::from(exponent);\n\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [Field; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if x.get_bit(num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n) -> [[Field; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut temporaries: [[Field; N]; M] = std::mem::zeroed();\n    for i in 0..M {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[Field; N]; M] = [[0; N]; M];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..M {\n        let idx = M - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]],\n) -> [[Field; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut temporaries: [[Field; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[Field; N]] = [];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result = result.push_front(T0);\n        } else {\n            result = result.push_front([0; N]);\n        };\n    }\n\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [Field; N],\n) -> std::option::Option<[Field; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one_u60: U60Repr<N, 2> = U60Repr::one();\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let mut Q = (params.modulus_u60 - one_u60).shr(primitive_root_log_size - 1);\n    let Q_minus_one_over_two_u60 = (Q - one_u60).shr(2);\n    let Q_minus_one_over_two: [Field; N] = U60Repr::into(Q_minus_one_over_two_u60);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [Field; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut result = Option::none();\n    let one: [Field; N] = __one::<N>();\n    if (__eq(check, one)) {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/fns/unconstrained_ops.nr"},"103":{"source":"use crate::params::BigNumParams;\nuse crate::utils::map::map;\n\nuse crate::fns::{\n    constrained_ops::{\n        add, assert_is_not_equal, conditional_select, derive_from_seed, div, eq, is_zero, mul, neg,\n        sub, udiv, udiv_mod, umod, validate_in_field, validate_in_range,\n    },\n    expressions::{__compute_quadratic_expression, evaluate_quadratic_expression},\n    serialization::{from_be_bytes, to_le_bytes},\n    unconstrained_ops::{\n        __add, __batch_invert, __batch_invert_slice, __derive_from_seed, __div, __eq, __invmod,\n        __is_zero, __mul, __neg, __pow, __sub, __tonelli_shanks_sqrt, __udiv_mod,\n    },\n};\nuse std::ops::{Add, Div, Mul, Neg, Sub};\n\npub struct RuntimeBigNum<let N: u32, let MOD_BITS: u32> {\n    pub limbs: [Field; N],\n    pub params: BigNumParams<N, MOD_BITS>,\n}\n\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNum<N, MOD_BITS> {}\n\n// All functions prefixed `__` are unconstrained!\n// They're not actually decorated as `unconstrained` because to return the `params` (as part of Self) from an `unconstrained` fn would cause range constraints. Instead, each `__` fn wraps a call to an unconstrained fn, so that the already-range-constrained `params` can be inserted into Self after the unconstrained call.\npub(crate) trait RuntimeBigNumTrait<let N: u32, let MOD_BITS: u32>: Neg + Add + Sub + Mul + Div + Eq {\n    fn new(params: BigNumParams<N, MOD_BITS>) -> Self;\n    fn one(params: BigNumParams<N, MOD_BITS>) -> Self;\n    fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self;\n    unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self;\n    fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [Field]) -> Self;\n    fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [Field; N]) -> Self;\n    fn from_be_bytes<let NBytes: u32>(params: BigNumParams<N, MOD_BITS>, x: [u8; NBytes]) -> Self;\n\n    fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes];\n\n    fn modulus(self) -> Self;\n    fn modulus_bits() -> u32;\n    fn num_limbs() -> u32;\n    // pub fn get(self) -> [Field];\n    fn get_limbs(self) -> [Field; N];\n    fn get_limb(self, idx: u32) -> Field;\n    fn set_limb(&mut self, idx: u32, value: Field);\n\n    unconstrained fn __eq(self, other: Self) -> bool;\n    unconstrained fn __is_zero(self) -> bool;\n\n    // unconstrained\n    fn __neg(self) -> Self;\n    // unconstrained\n    fn __add(self, other: Self) -> Self;\n    // unconstrained\n    fn __sub(self, other: Self) -> Self;\n    // unconstrained\n    fn __mul(self, other: Self) -> Self;\n    // unconstrained\n    fn __div(self, other: Self) -> Self;\n    // unconstrained\n    fn __udiv_mod(self, divisor: Self) -> (Self, Self);\n    // unconstrained\n    fn __invmod(self) -> Self;\n    // unconstrained\n    fn __pow(self, exponent: Self) -> Self;\n\n    // unconstrained\n    fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M];\n    unconstrained fn __batch_invert_slice<let M: u32>(to_invert: [Self]) -> [Self];\n\n    fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self>;\n\n    // unconstrained\n    fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self);\n\n    fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    );\n\n    fn eq(lhs: Self, rhs: Self) -> bool {\n        lhs == rhs\n    }\n    fn assert_is_not_equal(self, other: Self);\n    fn validate_in_field(self);\n    fn validate_in_range(self);\n    // pub fn validate_gt(self, lhs: Self, rhs: Self);\n\n    fn udiv_mod(numerator: Self, divisor: Self) -> (Self, Self);\n    fn udiv(numerator: Self, divisor: Self) -> Self;\n    fn umod(numerator: Self, divisor: Self) -> Self;\n\n    fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self;\n    fn is_zero(self) -> bool;\n}\n\nimpl<let N: u32, let MOD_BITS: u32> Neg for RuntimeBigNum<N, MOD_BITS> {\n    fn neg(self) -> Self {\n        let params = self.params;\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNumTrait<N, MOD_BITS> for RuntimeBigNum<N, MOD_BITS> {\n\n    fn new(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let limbs: [Field; N] = [0; N];\n        Self { limbs, params }\n    }\n\n    fn one(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let mut result = RuntimeBigNum::new(params);\n        result.limbs[0] = 1;\n        result\n    }\n\n    fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = __derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [Field]) -> Self {\n        Self { limbs: limbs.as_array(), params }\n    }\n\n    fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [Field; N]) -> Self {\n        Self { limbs, params }\n    }\n\n    fn from_be_bytes<let NBytes: u32>(params: BigNumParams<N, MOD_BITS>, x: [u8; NBytes]) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS, _>(x), params }\n    }\n\n    fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes] {\n        to_le_bytes::<_, MOD_BITS, _>(self.limbs)\n    }\n\n    fn modulus(self) -> Self {\n        let params = self.params;\n        Self { limbs: params.modulus, params }\n    }\n\n    fn modulus_bits() -> u32 {\n        MOD_BITS\n    }\n\n    fn num_limbs() -> u32 {\n        N\n    }\n\n    // fn get(self) -> [Field] {\n    //     self.get_limbs()\n    // }\n\n    fn get_limbs(self) -> [Field; N] {\n        self.limbs\n    }\n\n    fn get_limb(self, idx: u32) -> Field {\n        self.limbs[idx]\n    }\n\n    fn set_limb(&mut self, idx: u32, value: Field) {\n        self.limbs[idx] = value;\n    }\n\n    unconstrained fn __eq(self, other: Self) -> bool {\n        assert(self.params == other.params);\n        __eq(self.limbs, other.limbs)\n    }\n\n    unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __neg(self) -> Self {\n        let params = self.params;\n        let limbs = unsafe { __neg(params, self.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __add(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __sub(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __mul::<_, MOD_BITS>(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        let limbs = unsafe { __div::<_, MOD_BITS>(params, self.limbs, divisor.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = unsafe { __udiv_mod(self.limbs, divisor.limbs) };\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __invmod(self) -> Self {\n        let params = self.params;\n        assert(params.has_multiplicative_inverse);\n        let limbs = unsafe { __invmod::<_, MOD_BITS>(params, self.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __pow(self, exponent: Self) -> Self {\n        let params = self.params;\n        assert(params == exponent.params);\n        let limbs = unsafe { __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs =\n            unsafe { __batch_invert::<_, MOD_BITS, _>(params, x.map(|bn| Self::get_limbs(bn))) };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // Note: can't return a slice from this unconstrained to a constrained function.\n    unconstrained fn __batch_invert_slice<let M: u32>(x: [Self]) -> [Self] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs = {\n            let inv_slice =\n                __batch_invert_slice::<_, MOD_BITS>(params, x.map(|bn| Self::get_limbs(bn)));\n            inv_slice.as_array()\n        };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = self.params;\n        let maybe_limbs = unsafe { __tonelli_shanks_sqrt(params, self.limbs) };\n        maybe_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self) {\n        let (q_limbs, r_limbs) = unsafe {\n            __compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n                params,\n                map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                lhs_flags,\n                map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                rhs_flags,\n                map(linear_terms, |bn| Self::get_limbs(bn)),\n                linear_flags,\n            )\n        };\n        (Self { limbs: q_limbs, params }, Self { limbs: r_limbs, params })\n    }\n\n    fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) {\n        evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            rhs_flags,\n            map(linear_terms, |bn| Self::get_limbs(bn)),\n            linear_flags,\n        )\n    }\n\n    fn validate_in_field(self: Self) {\n        let params = self.params;\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    fn validate_in_range(self) {\n        validate_in_range::<_, MOD_BITS>(self.limbs);\n    }\n\n    fn assert_is_not_equal(self, other: Self) {\n        let params = self.params;\n        assert(params == other.params);\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    fn udiv(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    fn umod(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self {\n        let params = lhs.params;\n        assert(params == rhs.params);\n        Self { limbs: conditional_select(lhs.limbs, rhs.limbs, predicate), params }\n    }\n\n    fn is_zero(self) -> bool {\n        is_zero::<N, MOD_BITS>(self.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Add for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Sub for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Mul for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Div for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for RuntimeBigNum<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        let params = self.params;\n        assert(params == other.params);\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/runtime_bignum.nr"},"109":{"source":"/// Multiple entires in the `MUL_DE_BRUIJN_BIT` list do not map to a valid output of `v * 0x6c04f118e9966f6b`.\n/// This is a dummy value to fill the gaps in the map.\nglobal n1: u32 = 0xffffffff;\n\nglobal MUL_DE_BRUIJN_BIT: [u32; 128] = [\n    0, // change to 1 if you want bitSize(0) = 1\n    48, n1, n1, 31, n1, 15, 51, n1, 63, 5, n1, n1, n1, 19, n1, 23, 28, n1, n1, n1, 40, 36, 46, n1,\n    13, n1, n1, n1, 34, n1, 58, n1, 60, 2, 43, 55, n1, n1, n1, 50, 62, 4, n1, 18, 27, n1, 39, 45,\n    n1, n1, 33, 57, n1, 1, 54, n1, 49, n1, 17, n1, n1, 32, n1, 53, n1, 16, n1, n1, 52, n1, n1, n1,\n    64, 6, 7, 8, n1, 9, n1, n1, n1, 20, 10, n1, n1, 24, n1, 29, n1, n1, 21, n1, 11, n1, n1, 41, n1,\n    25, 37, n1, 47, n1, 30, 14, n1, n1, n1, n1, 22, n1, n1, 35, 12, n1, n1, n1, 59, 42, n1, n1, 61,\n    3, 26, 38, 44, n1, 56,\n];\n\npub unconstrained fn get_msb64(x: u64) -> u32 {\n    let mut v = x;\n    v |= v >> 1;\n    v |= v >> 2;\n    v |= v >> 4;\n    v |= v >> 8;\n    v |= v >> 16;\n    v |= v >> 32;\n    MUL_DE_BRUIJN_BIT[(std::wrapping_mul(v, 0x6c04f118e9966f6b)) >> 57]\n}\n\n// 1100\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/utils/msb.nr"},"110":{"source":"global TWO_POW_56: u64 = 0x100000000000000;\npub(crate) global TWO_POW_60: u64 = 0x1000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n//fields to u60rep conversion\n// field elements are 254 bits\n// so there will be 5 limbs\npub(crate) unconstrained fn field_to_u60rep(mut x: Field) -> (u64, u64, u64, u64, u64) {\n    // get the first 60 bits by casting to u64 and then taking the lower 60 bits\n    // we use the fact that this casting drops everything above 64 bits\n    let x_first_u64 = (x as u64);\n    let first: u64 = x_first_u64 % TWO_POW_60;\n    // this becomes the same as a integer division because we're removing the remainder\n    x = (x - (first as Field)) / (TWO_POW_60 as Field);\n    let x_second_u64 = (x as u64);\n    let second = x_second_u64 % TWO_POW_60;\n    x = (x - (second as Field)) / (TWO_POW_60 as Field);\n    let x_third_u64 = (x as u64);\n    let third = x_third_u64 % TWO_POW_60;\n    x = (x - (third as Field)) / (TWO_POW_60 as Field);\n    let x_fourth_u64 = (x as u64);\n    let fourth = x_fourth_u64 % TWO_POW_60;\n    x = (x - (fourth as Field)) / (TWO_POW_60 as Field);\n    let x_fifth_u64 = (x as u64);\n    let fifth = x_fifth_u64 % TWO_POW_60;\n    (first, second, third, fourth, fifth)\n}\n\n// Decomposes a single field into two 120 bit fields\npub unconstrained fn split_120_bits(mut x: Field) -> (Field, Field) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_56 = ((x as u64) % TWO_POW_56) as Field;\n\n    let low = low_lower_64 + TWO_POW_64 * low_upper_56;\n    let high = (x - low_upper_56) / TWO_POW_56 as Field;\n\n    (low, high)\n}\n\n/// Decomposes a single field into two 60 bit fields\n///\n/// Expects the input limb to be in the range [0, ..., 2^{120 - 1}]\nunconstrained fn __split_60_bits(x: Field) -> (u64, u64) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let x_lower_64 = (x as u64);\n    let low = x_lower_64 % TWO_POW_60;\n    let high = ((x - (low as Field)) / TWO_POW_60 as Field) as u64;\n\n    (low, high)\n}\n\n/// Decomposes a single field into two 60 bit fields\n///\n/// Expects the input limb to be in the range [0, ..., 2^{120 - 1}]\npub fn split_60_bits(x: Field) -> (u64, u64) {\n    // We assert that the two returned limbs fit within 60 bits each\n    // and reconstruct `x` when added together.\n    let (lo, hi) = unsafe { __split_60_bits(x) };\n    if !std::runtime::is_unconstrained() {\n        let lo_field = lo as Field;\n        let hi_field = hi as Field;\n        lo_field.assert_max_bit_size::<60>();\n        hi_field.assert_max_bit_size::<60>();\n        assert_eq(lo_field + (TWO_POW_60 as Field) * hi_field, x);\n    }\n\n    (lo, hi)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [Field; N] {\n    let mut normalized: [Field; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(next);\n\n        normalized[i] = lo;\n        next = input[i + 1] + hi;\n    }\n    {\n        let (lo, hi) = split_120_bits(next);\n        normalized[range - 1] = lo;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/utils/split_bits.nr"},"111":{"source":"use crate::utils::msb::get_msb64;\nuse crate::utils::split_bits;\nuse crate::utils::split_bits::{field_to_u60rep, TWO_POW_60};\n\n/**\n * @brief U60Repr represents a BigNum element as a sequence of 60-bit unsigned integers.\n *\n * @description: used in unconstrained functions when computing witness values.\n * It is helpful to use u60 types when evaluating addition operations that can overflow the field modulus,\n * as well as when performing bit shifts.\n */\npub struct U60Repr<let N: u32, let NumSegments: u32> {\n    pub(crate) limbs: [u64; N * NumSegments],\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Add for U60Repr<N, NumSegments> {\n    fn add(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut carry: u64 = 0;\n        for i in 0..N * NumSegments {\n            let mut add: u64 = self.limbs[i] + b.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            result.limbs[i] = add;\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Sub for U60Repr<N, NumSegments> {\n    fn sub(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut borrow: u64 = 0;\n        let mut borrow_in: u64 = 0;\n\n        for i in 0..N * NumSegments {\n            borrow = ((b.limbs[i] + borrow_in) > self.limbs[i]) as u64;\n            let sub = (borrow << 60) + self.limbs[i] - b.limbs[i] - borrow_in;\n            result.limbs[i] = sub;\n            borrow_in = borrow;\n        }\n\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::convert::From<[Field; N]> for U60Repr<N, NumSegments> {\n    fn from(input: [Field; N]) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..N {\n            let (lo, hi) = split_bits::split_60_bits(input[i]);\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n}\n\n// impl<let N: u32, let NumSegments: u32> std::convert::From<Field> for U60Repr<N, NumSegments> {\n//     fn from(input: Field) -> Self {\n//        let (low, mid, high) =  unsafe { field_to_u60rep(input) } ;\n//         let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n//         let N_u60: u32 = N * NumSegments;\n//         assert(N_u60 >=1, \"N must be at least 1\");\n//         if N_u60 == 1 {\n//             assert((mid ==0) & (high == 0), \"input field is too large to fit in a single limb\");\n//             result.limbs[0] = low;\n//         }\n//         else if N_u60 == 2{\n//             assert(high == 0, \"input field is too large to fit in two limbs\");\n//             result.limbs[0] = low;\n//             result.limbs[1] = mid;\n//         }else{\n//             result.limbs[0] = low;\n//             result.limbs[1] = mid;\n//             result.limbs[2] = high;\n//         }\n//         result\n//     }\n// }\n\nimpl<let N: u32, let NumSegments: u32> std::convert::Into<[Field; N]> for U60Repr<N, NumSegments> {\n    fn into(x: U60Repr<N, NumSegments>) -> [Field; N] {\n        let mut result: [Field; N] = [0; N];\n        let two_pow_60: Field = 0x1000000000000000;\n        for i in 0..N {\n            result[i] = x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * two_pow_60);\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::cmp::Eq for U60Repr<N, NumSegments> {\n    fn eq(self, other: Self) -> bool {\n        self.limbs == other.limbs\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> U60Repr<N, NumSegments> {\n\n    pub(crate) fn new<let NumFieldSegments: u32>(x: [Field; N * NumFieldSegments]) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..(N * NumFieldSegments) {\n            let (lo, hi) = split_bits::split_60_bits(x[i]);\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n\n    pub(crate) fn one() -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub(crate) unconstrained fn from_field(input: Field) -> Self {\n        let (first, second, third, fourth, fifth) = field_to_u60rep(input);\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        let N_u60: u32 = N * NumSegments;\n        assert(N_u60 >= 1, \"N must be at least 1\");\n        if N_u60 == 1 {\n            assert(\n                (second == 0) & (third == 0) & (fourth == 0) & (fifth == 0),\n                \"input field is too large to fit in a single limb\",\n            );\n            result.limbs[0] = first;\n        } else if N_u60 == 2 {\n            assert(\n                (third == 0) & (fourth == 0) & (fifth == 0),\n                \"input field is too large to fit in two limbs\",\n            );\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n        } else if N_u60 == 3 {\n            assert((fourth == 0) & (fifth == 0), \"input field is too large to fit in three limbs\");\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n        } else if N_u60 == 4 {\n            assert((fifth == 0), \"input field is too large to fit in four limbs\");\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n            result.limbs[3] = fourth;\n        } else {\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n            result.limbs[3] = fourth;\n            result.limbs[4] = fifth;\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn into_field_array(\n        x: U60Repr<N, NumSegments>,\n    ) -> [Field; N * NumSegments / 2] {\n        let mut result: [Field; N * NumSegments / 2] = [0; N * NumSegments / 2];\n        for i in 0..(N * NumSegments / 2) {\n            result[i] =\n                x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * TWO_POW_60 as Field);\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn gte(self, b: Self) -> bool {\n        let mut result = false;\n        let mut early_exit = false;\n        for i in 0..(N * NumSegments) {\n            let idx = (N * NumSegments) - 1 - i;\n            if (b.limbs[idx] == self.limbs[idx]) {\n                continue;\n            }\n\n            result = b.limbs[idx] < self.limbs[idx];\n            early_exit = true;\n            break;\n        }\n        if early_exit {\n            result\n        } else {\n            self.limbs[0] == b.limbs[0]\n        }\n    }\n\n    pub(crate) fn get_bit(self, bit: u32) -> bool {\n        let segment_index = bit / 60;\n        let uint_index = bit % 60;\n\n        let limb: u64 = self.limbs[segment_index];\n        let value = (limb >> uint_index as u8) & 1;\n        value == 1\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = (shift % 60) as u8;\n        let remainder_shift = (60 - limb_shift) as u8;\n        let mask: u64 = (((1 as u64) << limb_shift) - 1) << remainder_shift;\n        result.limbs[0] = (self.limbs[0 + num_shifted_limbs] >> limb_shift);\n\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i + num_shifted_limbs];\n            result.limbs[i] = value >> limb_shift;\n            let remainder: u64 = (value << remainder_shift) & mask;\n            result.limbs[i - 1] = result.limbs[i - 1] + remainder;\n        }\n        result\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr1(&mut self) {\n        let mut remainder = 0;\n\n        for i in 0..N * NumSegments {\n            let value = self.limbs[N * NumSegments - 1 - i];\n            self.limbs[N * NumSegments - 1 - i] = (value >> 1) + remainder;\n            remainder = (value & 1) << 59;\n        }\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shl(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; NumSegments * N] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = (shift % 60) as u8;\n        let remainder_shift: u8 = 60 - limb_shift as u8;\n\n        // 83\n        // limb shift = 1\n        // inside shift = 19 bits to the left\n        // meaning we have 19 carry bits and 41 remainder bits\n        let mask: u64 = (1 as u64 << 60) - 1;\n        //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n        let value = self.limbs[0];\n\n        let mut remainder = (value >> remainder_shift);\n        result.limbs[num_shifted_limbs] = (value << limb_shift) & mask;\n\n        // shift 84. num shifted = 1\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i];\n            let upshift = ((value << limb_shift) + remainder) & mask;\n            result.limbs[i + num_shifted_limbs] = upshift;\n            remainder = (value >> remainder_shift);\n            // let remainder: u64 = (self.limbs.get(i + num_shifted_limbs as u64) << remainder_shift as u8) & mask;\n            // result.limbs.set(i - 1, result.limbs.get(i - 1) + remainder);\n        }\n        result\n    }\n\n    pub(crate) fn increment(&mut self) {\n        let mut carry: u64 = 0;\n\n        let mut add: u64 = self.limbs[0] + 1;\n        carry = add >> 60;\n        add = add - (carry << 60);\n        self.limbs[0] = add;\n\n        for i in 1..NumSegments * N {\n            let mut add: u64 = self.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            self.limbs[i] = add;\n        }\n    }\n\n    pub(crate) unconstrained fn get_msb(val: Self) -> u32 {\n        let mut count = 0;\n        for i in 0..N * NumSegments {\n            let v = val.limbs[((N * NumSegments) - 1 - i)];\n            if (v > 0) {\n                count = 60 * ((N * NumSegments) - 1 - i) + get_msb64(v);\n                break;\n            }\n        }\n        count\n    }\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/utils/u60_representation.nr"},"113":{"source":"use dep::bignum::{params::BigNumParams, RuntimeBigNum};\n\npub fn encrypt<let Tau: u32, let Num: u32, let Bits: u32>(\n    params: BigNumParams<Num, Bits>,\n    key_set: [[Field; Num]; Tau + 1],\n    entropy: [bool; Tau],\n    message: bool,\n) -> RuntimeBigNum<Num, Bits> {\n    let mut terms = Vec::new();\n    for i in 0..Tau {\n        terms.push(\n            if entropy[i] {\n                RuntimeBigNum::from_array(params, key_set[i+1])\n            } else {\n                RuntimeBigNum::new(params)\n            }\n        );\n    }\n    let mut sum = unsafe { terms.slice.reduce(|sum, next| sum.__add(next)) };\n\n    let mut flags = [false; Tau + 1];\n    flags[Tau] = true;\n    terms.push(sum);\n\n    RuntimeBigNum::evaluate_quadratic_expression(\n        params,\n        [[]; 0],\n        [[]; 0],\n        [[]; 0],\n        [[]; 0],\n        terms.slice.as_array(),\n        flags,\n    );\n\n    if message {\n        let _1 = RuntimeBigNum::one(params);\n        let _2 = _1 + _1;\n        sum += RuntimeBigNum::from_array(params, key_set[1]).udiv(_2);\n    }\n    sum\n}\n\npub fn decrypt<let Limbs: u32, let Bits: u32>(\n    decryption_key: RuntimeBigNum<Limbs, Bits>,\n    ciphertext: RuntimeBigNum<Limbs, Bits>,\n) -> bool {\n    let _1 = RuntimeBigNum::one(ciphertext.params);\n    let _2 = _1 + _1;\n\n    let k = decryption_key;\n    let c = ciphertext;\n\n    // round_nearest(2*c/k)%2 == 1\n    (c.udiv(k) * _2 + (k.udiv(_2) + c.umod(k) * _2).udiv(k)).umod(_2) == _1\n}\n\n#[test]\nfn test_encrypt_decrypt() {\n    let dec_key_limbs = [1, 4, 2, 8, 5, 7, 0, 0, 0];\n    let dec_key = RuntimeBigNum::from_array(MC1031_params, dec_key_limbs);\n    let enc_key = [dec_key_limbs; 1289 + 1];\n    let mut entropy = [false; 1289];\n    for i in 0..123 {\n        entropy[(i * 456) % 1289 + 1] = true;\n    }\n\n    assert(decrypt(dec_key, encrypt(MC1031_params, enc_key, entropy, true)) == true);\n    assert(decrypt(dec_key, encrypt(MC1031_params, enc_key, entropy, false)) == false);\n}\n\n/* Old implementations using BigNums fixed since compile time */\n// TODO: cleaning up and refactoring in progress\n\n/*\nfn decrypt_noise(p: AGCD, c: AGCD) -> AGCD {\n    let _1: AGCD = BigNum::one();\n    let _2 = _1 + _1;\n\n    // ~ c%(p/2)\n    c.umod(p.udiv(_2))\n}\n\n\n\n// (Harcoded for security parameter=128)\npub fn validate_keypair<let Tau: u32>(\n    common_divisor_entropy: [Field; 8],\n    multiplier_entropy: [[Field; 2]; Tau + 1],\n    additive_entropy: [[Field; 2]; Tau + 1],\n    resulting_samples: [[Field; 9]; Tau + 1],\n) {\n    // Assert that p has 128*7 bits or less\n    let TWO_POW_120 = 0x1_00000_00000_00000_00000_00000_00000;\n    for i in 0..7 {\n        assert(common_divisor_entropy[i].lt(TWO_POW_120));\n    }\n    let TWO_POW_56 = 0x10000_00000_00000;\n    assert(common_divisor_entropy[7].lt(TWO_POW_56));\n\n    let mut decryption_key_limbs = [0; 9];\n    for i in 0..8 {\n        decryption_key_limbs[i] = common_divisor_entropy[i];\n    }\n    let decryption_key: MC1031 = BigNum::from_slice(decryption_key_limbs);\n\n    for i in 0..Tau + 1 {\n        // Assert that q's have 128+7 bits or less\n        assert(multiplier_entropy[i][0].lt(TWO_POW_120));\n        assert(multiplier_entropy[i][1].lt((2 << 15) as Field));\n\n        // Assert that r's have 128 bits or less\n        assert(additive_entropy[i][0].lt(TWO_POW_120));\n        assert(additive_entropy[i][1].lt((2 << 8) as Field));\n\n        let mut multiplier_limbs = [0; 9];\n        multiplier_limbs[0] = multiplier_entropy[i][0];\n        multiplier_limbs[1] = multiplier_entropy[i][1];\n        let multiplier = BigNum::from_slice(multiplier_limbs);\n\n        let mut added_noise_limbs = [0; 9];\n        added_noise_limbs[0] = additive_entropy[i][0];\n        added_noise_limbs[1] = additive_entropy[i][1];\n        let added_noise = BigNum::from_slice(added_noise_limbs);\n        let TWO_POW_127 = BigNum::from_slice([0, 0x80, 0, 0, 0, 0, 0, 0, 0]);\n\n        assert(\n            resulting_samples[i] == (decryption_key * multiplier + added_noise - TWO_POW_127).limbs,\n        );\n    }\n}\n*/\n\n/*\n#[test]\nfn uniform_noise_potential_detector() {\n    let _1: AGCD = BigNum::one();\n    let _2 = _1 + _1;\n\n    let dk = BigNum::from_slice([1, 4, 2, 8, 5, 7, 0, 0, 0]);\n    let ek = [dk + _1; OLD_TAU];\n    let mut entropy = [false; OLD_TAU];\n    for i in 0..15 {\n        entropy[(i * 7) % OLD_TAU] = true;\n    }\n    let real_noise = decrypt_noise(dk, encrypt(ek, entropy, true));\n    let fake_noise = decrypt_noise(dk, BigNum::from_slice([4, 4, 6, 2, 6, 7, 4, 2, 2]));\n    println(f\"real_noise: {real_noise}\");\n    println(f\"fake_noise: {fake_noise}\");\n}\n*/\n\n// Maximum Cyphertext considered (integers modulo 2^1031)\nglobal MC1031_params: BigNumParams<9, 1031> = BigNumParams {\n    modulus: [\n        0xffffffffffffffffffffffffffffff,\n        0xffffffffffffffffffffffffffffff,\n        0xffffffffffffffffffffffffffffff,\n        0xffffffffffffffffffffffffffffff,\n        0xffffffffffffffffffffffffffffff,\n        0xffffffffffffffffffffffffffffff,\n        0xffffffffffffffffffffffffffffff,\n        0xffffffffffffffffffffffffffffff,\n        0x7fffffffffffffffff,\n    ],\n    double_modulus: [\n        0x01fffffffffffffffffffffffffffffe,\n        0x01fffffffffffffffffffffffffffffe,\n        0x01fffffffffffffffffffffffffffffe,\n        0x01fffffffffffffffffffffffffffffe,\n        0x01fffffffffffffffffffffffffffffe,\n        0x01fffffffffffffffffffffffffffffe,\n        0x01fffffffffffffffffffffffffffffe,\n        0x01fffffffffffffffffffffffffffffe,\n        0xfffffffffffffffffe,\n    ],\n    modulus_u60: U60Repr {\n        limbs: [\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x07ff,\n        ],\n    },\n    modulus_u60_x4: U60Repr {\n        limbs: [\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x0fffffffffffffff,\n            0x07ff,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n        ],\n    },\n    redc_param: [0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08000000000000000000],\n    has_multiplicative_inverse: false,\n};\nuse dep::bignum::utils::u60_representation::U60Repr;\n","path":"/root/box/terry-escape/packages/noir/libs/cheon_stehle/src/lib.nr"}},"names":["main"],"brillig_names":["decompose_hint","__add_with_flags","__udiv_mod","__compute_quadratic_expression_with_borrow_flags","__validate_gt_remainder","__mul","__compute_quadratic_expression_with_borrow_flags","__sub_with_flags","output_detect","output_board","directive_invert"]}